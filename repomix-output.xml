This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
backend/
  config/
    database.js
  controllers/
    authController.js
    messageController.js
  db/
    migrations/
      20260214044705-create-user.js
      20260214044721-create-conversation.js
      20260214044731-create-message.js
      20260214044745-create-conversation-participant.js
      20260215163105-create-message-reaction.js
      20260216113952-add-search-vector.js
      20260216120256-partition-messages-table.js
    models/
      conversation.js
      conversationparticipant.js
      index.js
      message.js
      messagereaction.js
      user.js
  lib/
    cloudinary.js
    queue.js
    rateLimiter.js
    redis.js
  routes/
    auth.js
    upload.js
  sockets/
    index.js
  workers/
    chatWorker.js
    receiptWorker.js
  .env
  .sequelizerc
  package.json
  server.js
frontend/
  public/
    vite.svg
  src/
    api/
      axios.js
    assets/
      react.svg
    lib/
      socket.js
    pages/
      Chat.jsx
      Login.jsx
      Signup.jsx
    store/
      useAuthStore.js
    App.css
    App.jsx
    index.css
    main.jsx
  .gitignore
  eslint.config.js
  index.html
  package.json
  postcss.config.js
  README.md
  taiwind.config.js
  vite.config.js
README.md
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="backend/.env">
PORT=5001
NODE_ENV=development

# Database Config (Tailored for macOS default)
DB_USERNAME=anirudh
DB_PASSWORD=null
DB_NAME=nexus_chat
DB_HOST=127.0.0.1
DB_DIALECT=postgres

# Security (Change these for production)
JWT_SECRET=b7fdb3dcbe47a11f10a048a07daf400a3f5859a4e01a09ed90049fefdd686dac
CLOUDINARY_CLOUD_NAME=dbusnbuzm
CLOUDINARY_API_KEY=135112947277763
CLOUDINARY_API_SECRET=QD37A9r1_P0ndrU8uyFajTowLXU

# Redis Config
REDIS_URL=redis://127.0.0.1:6379
</file>

<file path="backend/config/database.js">
const path = require("path");
// Force load .env from the backend root directory
require("dotenv").config({ path: path.resolve(__dirname, "../.env") });

// Diagnostic Log (Will show in terminal when server starts)
console.log("üîß DB Config Loading...");
console.log(`   - Username: ${process.env.DB_USERNAME || "UNDEFINED"}`);
console.log(
  `   - Database: ${process.env.DB_NAME || "UNDEFINED (Defaulting to System User)"}`,
);

module.exports = {
  development: {
    username: process.env.DB_USERNAME || "postgres",
    password: process.env.DB_PASSWORD || "postgres",
    database: process.env.DB_NAME || "nexus_chat",
    host: process.env.DB_HOST || "127.0.0.1",
    dialect: "postgres",
    logging: false,
  },
  production: {
    use_env_variable: "DATABASE_URL",
    dialect: "postgres",
    dialectOptions: {
      ssl: {
        require: true,
        rejectUnauthorized: false,
      },
    },
  },
};
</file>

<file path="backend/controllers/authController.js">
const bcrypt = require("bcryptjs");
const jwt = require("jsonwebtoken");
const { User } = require("../db/models");

const generateToken = (user) => {
  return jwt.sign(
    { id: user.id, username: user.username },
    process.env.JWT_SECRET || "secret",
    { expiresIn: "7d" },
  );
};

const register = async (req, res) => {
  try {
    const { username, email, password } = req.body;
    console.log(`üìù Register attempt: ${username} | ${email}`);

    // 1. Check if EMAIL exists
    const existingEmail = await User.findOne({ where: { email } });
    if (existingEmail) {
      console.log("‚ùå Email already exists");
      return res.status(400).json({ message: "Email already exists" });
    }

    // 2. Check if USERNAME exists
    const existingUsername = await User.findOne({ where: { username } });
    if (existingUsername) {
      console.log("‚ùå Username already exists");
      return res.status(400).json({ message: "Username already taken" });
    }

    // Hash password
    const hashedPassword = await bcrypt.hash(password, 10);

    // Create User
    const newUser = await User.create({
      username,
      email,
      password: hashedPassword,
    });

    console.log(`‚úÖ User created: ${newUser.id}`);

    const token = generateToken(newUser);

    res.status(201).json({
      message: "User created successfully",
      user: {
        id: newUser.id,
        username: newUser.username,
        email: newUser.email,
        avatar: newUser.avatar,
      },
      token,
    });
  } catch (error) {
    console.error("üî• CRITICAL REGISTER ERROR:", error);
    res
      .status(500)
      .json({ message: "Internal Server Error", error: error.message });
  }
};

const login = async (req, res) => {
  try {
    const { email, password } = req.body;

    const user = await User.findOne({ where: { email } });
    if (!user) return res.status(400).json({ message: "Invalid credentials" });

    const isMatch = await bcrypt.compare(password, user.password);
    if (!isMatch)
      return res.status(400).json({ message: "Invalid credentials" });

    const token = generateToken(user);

    res.json({
      message: "Login successful",
      user: {
        id: user.id,
        username: user.username,
        email: user.email,
        avatar: user.avatar,
      },
      token,
    });
  } catch (error) {
    console.error("Login Error:", error);
    res.status(500).json({ message: "Server error" });
  }
};

module.exports = { register, login };
</file>

<file path="backend/controllers/messageController.js">
const {
  Message,
  User,
  MessageReaction,
  ConversationParticipant,
  Sequelize,
} = require("../db/models");
const redisClient = require("../lib/redis");

const CACHE_TTL = 3600; // Cache for 1 hour (in seconds)

// --- GET MESSAGES (With Read Receipts) ---
exports.getMessages = async (req, res) => {
  try {
    const { channelId } = req.params;
    const { page = 1 } = req.query;
    const limit = 20;
    const offset = (page - 1) * limit;

    // 1. Fetch Participant Read Status for the Blue Ticks
    // We need to know "User X read up to Message Y"
    const participants = await ConversationParticipant.findAll({
      where: { conversationId: channelId },
      attributes: ["userId", "lastReadMessageId"],
    });

    // Convert to a simple map: { userId: lastReadId }
    const readStatus = {};
    participants.forEach((p) => {
      readStatus[p.userId] = p.lastReadMessageId;
    });

    const cacheKey = `messages:channel:${channelId}`;

    // 2. Try Cache (Only for Page 1)
    if (page == 1) {
      const cachedData = await redisClient.lRange(cacheKey, 0, limit - 1);

      if (cachedData && cachedData.length > 0) {
        console.log(`‚ö° Cache HIT for ${cacheKey}`);
        const messages = cachedData.map((item) => JSON.parse(item));

        return res.json({
          messages: messages.reverse(),
          hasMore: messages.length === limit,
          readStatus, // Pass read status even on cache hit
        });
      }
    }

    console.log(`üê¢ Cache MISS for ${cacheKey} (Page ${page})`);

    // 3. Fetch from DB
    const messages = await Message.findAll({
      where: { conversationId: channelId },
      include: [
        {
          model: User,
          as: "sender",
          attributes: ["username", "avatar"],
        },
        {
          model: MessageReaction,
          as: "reactions",
          attributes: ["id", "emoji", "userId"],
          include: [{ model: User, as: "user", attributes: ["username"] }],
        },
      ],
      order: [["createdAt", "DESC"]],
      limit: limit,
      offset: offset,
    });

    // 4. Format Data
    const formatted = messages.map((msg) => ({
      id: msg.id,
      content: msg.content,
      attachmentUrl: msg.attachmentUrl,
      sender: msg.sender.username,
      senderId: msg.senderId,
      time: new Date(msg.createdAt).toLocaleTimeString([], {
        hour: "2-digit",
        minute: "2-digit",
      }),
      reactions: msg.reactions || [],
    }));

    // 5. Update Cache (Warmup) - Only for Page 1
    if (page == 1 && formatted.length > 0) {
      await redisClient.del(cacheKey);
      const strings = formatted.map((m) => JSON.stringify(m));
      await redisClient.rPush(cacheKey, strings);
      await redisClient.expire(cacheKey, CACHE_TTL);
    }

    // 6. Response
    res.json({
      messages: formatted.reverse(),
      hasMore: messages.length === limit,
      readStatus, // Pass read status on DB fetch
    });
  } catch (error) {
    console.error("GetMessages Error:", error);
    res.status(500).json({ message: "Server Error" });
  }
};

// --- REACT TO MESSAGE ---
exports.reactToMessage = async (req, res) => {
  try {
    const { messageId } = req.params;
    const { emoji, userId } = req.body;

    const targetMessage = await Message.findByPk(messageId);
    if (!targetMessage)
      return res.status(404).json({ message: "Message not found" });

    const existing = await MessageReaction.findOne({
      where: { messageId, userId, emoji },
    });

    let result;
    if (existing) {
      await existing.destroy();
      result = { action: "removed", messageId, emoji, userId };
    } else {
      const newReaction = await MessageReaction.create({
        messageId,
        userId,
        emoji,
      });
      result = { action: "added", reaction: newReaction };
    }

    // INVALIDATE CACHE
    const cacheKey = `messages:channel:${targetMessage.conversationId}`;
    await redisClient.del(cacheKey);
    console.log(`üóëÔ∏è Invalidated Cache: ${cacheKey}`);

    return res.json(result);
  } catch (error) {
    console.error("Reaction Error:", error);
    res.status(500).json({ message: "Reaction failed" });
  }
};

// --- SEARCH MESSAGES (Prefix Support) ---
exports.searchMessages = async (req, res) => {
  try {
    const { channelId } = req.params;
    const { q } = req.query;

    if (!q || q.trim().length === 0) {
      return res.json({ messages: [] });
    }

    // Sanitize and Format for Prefix Search (e.g., "Hello World" -> "Hello:* & World:*")
    const formattedQuery = q
      .trim()
      .split(/\s+/)
      .map((term) => {
        const cleanTerm = term.replace(/[^\w]/g, "");
        return cleanTerm ? `${cleanTerm}:*` : "";
      })
      .filter(Boolean)
      .join(" & ");

    if (!formattedQuery) {
      return res.json({ messages: [] });
    }

    const messages = await Message.findAll({
      where: {
        conversationId: channelId,
        [Sequelize.Op.and]: Sequelize.literal(
          `"searchVector" @@ to_tsquery('english', '${formattedQuery}')`,
        ),
      },
      include: [
        {
          model: User,
          as: "sender",
          attributes: ["username", "avatar"],
        },
        {
          model: MessageReaction,
          as: "reactions",
          include: [{ model: User, as: "user", attributes: ["username"] }],
        },
      ],
      order: [["createdAt", "DESC"]],
      limit: 50,
    });

    const formatted = messages.map((msg) => ({
      id: msg.id,
      content: msg.content,
      attachmentUrl: msg.attachmentUrl,
      sender: msg.sender.username,
      senderId: msg.senderId,
      time: new Date(msg.createdAt).toLocaleTimeString([], {
        hour: "2-digit",
        minute: "2-digit",
      }),
      reactions: msg.reactions || [],
    }));

    res.json({ messages: formatted });
  } catch (error) {
    console.error("Search Error:", error);
    res.status(500).json({ message: "Search failed" });
  }
};
</file>

<file path="backend/db/migrations/20260214044705-create-user.js">
"use strict";
module.exports = {
  async up(queryInterface, Sequelize) {
    await queryInterface.createTable("Users", {
      id: {
        allowNull: false,
        autoIncrement: true,
        primaryKey: true,
        type: Sequelize.INTEGER,
      },
      username: {
        type: Sequelize.STRING,
        allowNull: false,
        unique: true,
      },
      email: {
        type: Sequelize.STRING,
        allowNull: false,
        unique: true,
      },
      password: {
        type: Sequelize.STRING,
        allowNull: false,
      },
      avatar: {
        type: Sequelize.STRING,
        defaultValue: "https://via.placeholder.com/150",
      },
      createdAt: { allowNull: false, type: Sequelize.DATE },
      updatedAt: { allowNull: false, type: Sequelize.DATE },
    });
  },
  async down(queryInterface, Sequelize) {
    await queryInterface.dropTable("Users");
  },
};
</file>

<file path="backend/db/migrations/20260214044721-create-conversation.js">
"use strict";
module.exports = {
  async up(queryInterface, Sequelize) {
    await queryInterface.createTable("Conversations", {
      id: {
        allowNull: false,
        autoIncrement: true,
        primaryKey: true,
        type: Sequelize.INTEGER,
      },
      type: {
        type: Sequelize.ENUM("DIRECT", "GROUP"),
        defaultValue: "DIRECT",
      },
      name: {
        type: Sequelize.STRING,
        allowNull: true,
      },
      createdAt: { allowNull: false, type: Sequelize.DATE },
      updatedAt: { allowNull: false, type: Sequelize.DATE },
    });
  },
  async down(queryInterface, Sequelize) {
    await queryInterface.dropTable("Conversations");
  },
};
</file>

<file path="backend/db/migrations/20260214044731-create-message.js">
"use strict";
module.exports = {
  async up(queryInterface, Sequelize) {
    await queryInterface.createTable("Messages", {
      id: {
        allowNull: false,
        autoIncrement: true,
        primaryKey: true,
        type: Sequelize.INTEGER,
      },
      content: {
        type: Sequelize.TEXT,
        allowNull: true,
      },
      attachmentUrl: {
        type: Sequelize.STRING,
        allowNull: true,
      },
      senderId: {
        type: Sequelize.INTEGER,
        allowNull: false,
        references: { model: "Users", key: "id" }, // Foreign Key
        onDelete: "CASCADE",
      },
      conversationId: {
        type: Sequelize.INTEGER,
        allowNull: false,
        references: { model: "Conversations", key: "id" }, // Foreign Key
        onDelete: "CASCADE",
      },
      createdAt: { allowNull: false, type: Sequelize.DATE },
      updatedAt: { allowNull: false, type: Sequelize.DATE },
    });
  },
  async down(queryInterface, Sequelize) {
    await queryInterface.dropTable("Messages");
  },
};
</file>

<file path="backend/db/migrations/20260214044745-create-conversation-participant.js">
"use strict";
module.exports = {
  async up(queryInterface, Sequelize) {
    await queryInterface.createTable("ConversationParticipants", {
      id: {
        allowNull: false,
        autoIncrement: true,
        primaryKey: true,
        type: Sequelize.INTEGER,
      },
      userId: {
        type: Sequelize.INTEGER,
        references: { model: "Users", key: "id" },
        onDelete: "CASCADE",
      },
      conversationId: {
        type: Sequelize.INTEGER,
        references: { model: "Conversations", key: "id" },
        onDelete: "CASCADE",
      },
      lastReadMessageId: {
        type: Sequelize.INTEGER,
        defaultValue: 0,
      },
      createdAt: { allowNull: false, type: Sequelize.DATE },
      updatedAt: { allowNull: false, type: Sequelize.DATE },
    });
  },
  async down(queryInterface, Sequelize) {
    await queryInterface.dropTable("ConversationParticipants");
  },
};
</file>

<file path="backend/db/migrations/20260215163105-create-message-reaction.js">
"use strict";
module.exports = {
  async up(queryInterface, Sequelize) {
    await queryInterface.createTable("MessageReactions", {
      id: {
        allowNull: false,
        autoIncrement: true,
        primaryKey: true,
        type: Sequelize.INTEGER,
      },
      emoji: {
        type: Sequelize.STRING,
        allowNull: false,
      },
      userId: {
        type: Sequelize.INTEGER,
        allowNull: false,
        references: { model: "Users", key: "id" }, // FK to User
        onDelete: "CASCADE",
      },
      messageId: {
        type: Sequelize.INTEGER,
        allowNull: false,
        references: { model: "Messages", key: "id" }, // FK to Message
        onDelete: "CASCADE",
      },
      createdAt: {
        allowNull: false,
        type: Sequelize.DATE,
      },
      updatedAt: {
        allowNull: false,
        type: Sequelize.DATE,
      },
    });
  },
  async down(queryInterface, Sequelize) {
    await queryInterface.dropTable("MessageReactions");
  },
};
</file>

<file path="backend/db/migrations/20260216113952-add-search-vector.js">
"use strict";

module.exports = {
  async up(queryInterface, Sequelize) {
    return queryInterface.sequelize.transaction(async (t) => {
      // 1. Add the column
      await queryInterface.addColumn(
        "Messages",
        "searchVector",
        {
          type: Sequelize.TSVECTOR,
          allowNull: true,
        },
        { transaction: t },
      );

      // 2. Add the Index (The secret sauce for speed)
      await queryInterface.sequelize.query(
        `
        CREATE INDEX message_search_idx ON "Messages" USING GIN ("searchVector");
      `,
        { transaction: t },
      );

      // 3. Create the Trigger Function
      // This function converts text to vector automatically
      await queryInterface.sequelize.query(
        `
        CREATE FUNCTION message_search_vector_update() RETURNS trigger AS $$
        BEGIN
          NEW."searchVector" := to_tsvector('english', NEW.content);
          RETURN NEW;
        END
        $$ LANGUAGE plpgsql;
      `,
        { transaction: t },
      );

      // 4. Attach Trigger to Table
      await queryInterface.sequelize.query(
        `
        CREATE TRIGGER message_search_vector_update
        BEFORE INSERT OR UPDATE ON "Messages"
        FOR EACH ROW EXECUTE PROCEDURE message_search_vector_update();
      `,
        { transaction: t },
      );

      // 5. Backfill existing data
      await queryInterface.sequelize.query(
        `
        UPDATE "Messages" SET "searchVector" = to_tsvector('english', content);
      `,
        { transaction: t },
      );
    });
  },

  async down(queryInterface, Sequelize) {
    return queryInterface.sequelize.transaction(async (t) => {
      await queryInterface.sequelize.query(
        'DROP TRIGGER IF EXISTS message_search_vector_update ON "Messages"',
        { transaction: t },
      );
      await queryInterface.sequelize.query(
        "DROP FUNCTION IF EXISTS message_search_vector_update",
        { transaction: t },
      );
      await queryInterface.removeIndex("Messages", "message_search_idx", {
        transaction: t,
      });
      await queryInterface.removeColumn("Messages", "searchVector", {
        transaction: t,
      });
    });
  },
};
</file>

<file path="backend/db/migrations/20260216120256-partition-messages-table.js">
"use strict";

module.exports = {
  async up(queryInterface, Sequelize) {
    const transaction = await queryInterface.sequelize.transaction();
    try {
      // 1. Rename the existing monolithic table to keep it as backup
      // We also rename the indexes to free up the names
      await queryInterface.sequelize.query(
        'ALTER TABLE "Messages" RENAME TO "Messages_Backup";',
        { transaction },
      );

      // 2. Drop the Foreign Key on MessageReactions
      // It references "Messages", but that table is gone (renamed).
      // We need to drop the constraint to avoid conflicts.
      // Note: We use "CASCADE" to force the drop of the constraint.
      await queryInterface.sequelize.query(
        'ALTER TABLE "MessageReactions" DROP CONSTRAINT IF EXISTS "MessageReactions_messageId_fkey";',
        { transaction },
      );

      // 3. Create the NEW Partitioned Parent Table
      // Notice: PRIMARY KEY is now (id, "createdAt")
      await queryInterface.sequelize.query(
        `
        CREATE TABLE "Messages" (
          id SERIAL,
          content TEXT,
          "attachmentUrl" VARCHAR(255),
          "senderId" INTEGER NOT NULL,
          "conversationId" INTEGER NOT NULL,
          "searchVector" TSVECTOR, 
          "createdAt" TIMESTAMPTZ NOT NULL,
          "updatedAt" TIMESTAMPTZ NOT NULL,
          PRIMARY KEY (id, "createdAt")
        ) PARTITION BY RANGE ("createdAt");
      `,
        { transaction },
      );

      // 4. Create Partitions (Time-Based Chunks)

      // Partition 1: History (Everything before 2026)
      await queryInterface.sequelize.query(
        `
        CREATE TABLE "messages_archive" PARTITION OF "Messages"
        FOR VALUES FROM (MINVALUE) TO ('2026-01-01');
      `,
        { transaction },
      );

      // Partition 2: Jan 2026
      await queryInterface.sequelize.query(
        `
        CREATE TABLE "messages_2026_01" PARTITION OF "Messages"
        FOR VALUES FROM ('2026-01-01') TO ('2026-02-01');
      `,
        { transaction },
      );

      // Partition 3: Feb 2026 (Current Month)
      await queryInterface.sequelize.query(
        `
        CREATE TABLE "messages_2026_02" PARTITION OF "Messages"
        FOR VALUES FROM ('2026-02-01') TO ('2026-03-01');
      `,
        { transaction },
      );

      // Partition 4: Future Proofing (Next few months)
      await queryInterface.sequelize.query(
        `
        CREATE TABLE "messages_2026_future" PARTITION OF "Messages"
        FOR VALUES FROM ('2026-03-01') TO (MAXVALUE);
      `,
        { transaction },
      );

      // 5. Restore Indexes on the Parent (Postgres propagates these to children)
      // Index for efficient channel fetching
      await queryInterface.sequelize.query(
        `
        CREATE INDEX "idx_messages_conversationId" ON "Messages" ("conversationId");
      `,
        { transaction },
      );

      // Index for Full Text Search (GIN)
      await queryInterface.sequelize.query(
        `
        CREATE INDEX "idx_messages_searchVector" ON "Messages" USING GIN ("searchVector");
      `,
        { transaction },
      );

      // 6. Migrate Data from Backup to New Table
      // This automatically routes rows to the correct partition!
      await queryInterface.sequelize.query(
        `
        INSERT INTO "Messages" (id, content, "attachmentUrl", "senderId", "conversationId", "searchVector", "createdAt", "updatedAt")
        SELECT id, content, "attachmentUrl", "senderId", "conversationId", "searchVector", "createdAt", "updatedAt"
        FROM "Messages_Backup";
      `,
        { transaction },
      );

      // 7. Fix the Serial Sequence
      // The new table created a new sequence. We must set it to the max id of the old data.
      await queryInterface.sequelize.query(
        `
        SELECT setval(pg_get_serial_sequence('"Messages"', 'id'), COALESCE(MAX(id), 1)) FROM "Messages";
      `,
        { transaction },
      );

      // 8. Re-Apply Search Vector Trigger
      // The old trigger pointed to Messages_Backup. We need a new one for the new table.
      await queryInterface.sequelize.query(
        `
        CREATE TRIGGER message_search_vector_update
        BEFORE INSERT OR UPDATE ON "Messages"
        FOR EACH ROW EXECUTE PROCEDURE message_search_vector_update();
      `,
        { transaction },
      );

      await transaction.commit();
    } catch (error) {
      await transaction.rollback();
      throw error;
    }
  },

  async down(queryInterface, Sequelize) {
    // Reverting partitioning is hard, usually we just drop the partitioned table
    // and rename the backup back.
    const transaction = await queryInterface.sequelize.transaction();
    try {
      await queryInterface.dropTable("Messages", { transaction });
      await queryInterface.renameTable("Messages_Backup", "Messages", {
        transaction,
      });

      // Restore FK
      await queryInterface.addConstraint("MessageReactions", {
        fields: ["messageId"],
        type: "foreign key",
        name: "MessageReactions_messageId_fkey",
        references: {
          table: "Messages",
          field: "id",
        },
        onDelete: "cascade",
        onUpdate: "cascade",
        transaction,
      });

      await transaction.commit();
    } catch (error) {
      await transaction.rollback();
      throw error;
    }
  },
};
</file>

<file path="backend/db/models/conversation.js">
"use strict";
const { Model } = require("sequelize");
module.exports = (sequelize, DataTypes) => {
  class Conversation extends Model {
    static associate(models) {
      // Define associations here
      Conversation.belongsToMany(models.User, {
        through: "ConversationParticipants", // Using string matches the model name
        foreignKey: "conversationId",
        as: "participants",
      });
      Conversation.hasMany(models.Message, {
        foreignKey: "conversationId",
        as: "messages",
      });
      Conversation.hasMany(models.ConversationParticipant, {
        foreignKey: "conversationId",
        as: "participantDetails",
      });
    }
  }
  Conversation.init(
    {
      type: {
        type: DataTypes.ENUM("DIRECT", "GROUP"), // <--- FIX IS HERE
        defaultValue: "DIRECT",
      },
      name: {
        type: DataTypes.STRING,
        allowNull: true,
      },
    },
    {
      sequelize,
      modelName: "Conversation",
    },
  );
  return Conversation;
};
</file>

<file path="backend/db/models/conversationparticipant.js">
"use strict";
const { Model } = require("sequelize");
module.exports = (sequelize, DataTypes) => {
  class ConversationParticipant extends Model {
    static associate(models) {
      // Define associations here
      ConversationParticipant.belongsTo(models.User, { foreignKey: "userId" });
      ConversationParticipant.belongsTo(models.Conversation, {
        foreignKey: "conversationId",
      });
    }
  }
  ConversationParticipant.init(
    {
      userId: {
        type: DataTypes.INTEGER,
        allowNull: false,
      },
      conversationId: {
        type: DataTypes.INTEGER,
        allowNull: false,
      },
      lastReadMessageId: {
        type: DataTypes.INTEGER,
        defaultValue: 0,
      },
    },
    {
      sequelize,
      modelName: "ConversationParticipant",
    },
  );
  return ConversationParticipant;
};
</file>

<file path="backend/db/models/index.js">
'use strict';

const fs = require('fs');
const path = require('path');
const Sequelize = require('sequelize');
const process = require('process');
const basename = path.basename(__filename);
const env = process.env.NODE_ENV || 'development';
const config = require(__dirname + '/../../config/database.js')[env];
const db = {};

let sequelize;
if (config.use_env_variable) {
  sequelize = new Sequelize(process.env[config.use_env_variable], config);
} else {
  sequelize = new Sequelize(config.database, config.username, config.password, config);
}

fs
  .readdirSync(__dirname)
  .filter(file => {
    return (
      file.indexOf('.') !== 0 &&
      file !== basename &&
      file.slice(-3) === '.js' &&
      file.indexOf('.test.js') === -1
    );
  })
  .forEach(file => {
    const model = require(path.join(__dirname, file))(sequelize, Sequelize.DataTypes);
    db[model.name] = model;
  });

Object.keys(db).forEach(modelName => {
  if (db[modelName].associate) {
    db[modelName].associate(db);
  }
});

db.sequelize = sequelize;
db.Sequelize = Sequelize;

module.exports = db;
</file>

<file path="backend/db/models/message.js">
"use strict";
const { Model } = require("sequelize");
module.exports = (sequelize, DataTypes) => {
  class Message extends Model {
    static associate(models) {
      Message.belongsTo(models.User, { foreignKey: "senderId", as: "sender" });
      Message.belongsTo(models.Conversation, {
        foreignKey: "conversationId",
        as: "conversation",
      });

      Message.hasMany(models.MessageReaction, {
        foreignKey: "messageId",
        as: "reactions",
      });
    }
  }
  Message.init(
    {
      // Explicitly define ID so Sequelize knows it's part of the PK
      id: {
        type: DataTypes.INTEGER,
        primaryKey: true, // Logic PK
        autoIncrement: true,
      },
      content: DataTypes.TEXT,
      attachmentUrl: DataTypes.STRING,
      senderId: DataTypes.INTEGER,
      conversationId: DataTypes.INTEGER,
      searchVector: DataTypes.TSVECTOR, // Keep this for reference
      // Important: Partitioning relies on createdAt
      createdAt: {
        type: DataTypes.DATE,
        primaryKey: true, // DB PK includes this
      },
    },
    {
      sequelize,
      modelName: "Message",
      // Optimization: Disable 'returning: true' for inserts if using older Postgres
      // but modern Postgres handles partitioned inserts fine.
    },
  );
  return Message;
};
</file>

<file path="backend/db/models/messagereaction.js">
"use strict";
const { Model } = require("sequelize");
module.exports = (sequelize, DataTypes) => {
  class MessageReaction extends Model {
    static associate(models) {
      // Define associations here
      MessageReaction.belongsTo(models.User, {
        foreignKey: "userId",
        as: "user",
      });
      MessageReaction.belongsTo(models.Message, {
        foreignKey: "messageId",
        as: "message",
      });
    }
  }
  MessageReaction.init(
    {
      emoji: DataTypes.STRING,
      userId: DataTypes.INTEGER,
      messageId: DataTypes.INTEGER,
    },
    {
      sequelize,
      modelName: "MessageReaction",
    },
  );
  return MessageReaction;
};
</file>

<file path="backend/db/models/user.js">
"use strict";
const { Model } = require("sequelize");
module.exports = (sequelize, DataTypes) => {
  class User extends Model {
    static associate(models) {
      // 1. User belongs to many Conversations (Group Chats)
      User.belongsToMany(models.Conversation, {
        through: "ConversationParticipants",
        foreignKey: "userId",
        as: "conversations",
      });

      // 2. User has sent many Messages
      User.hasMany(models.Message, {
        foreignKey: "senderId",
        as: "messages",
      });

      // 3. NEW: User has made many Reactions
      User.hasMany(models.MessageReaction, {
        foreignKey: "userId",
        as: "reactions",
      });
    }
  }

  User.init(
    {
      username: {
        type: DataTypes.STRING,
        allowNull: false,
        unique: true,
      },
      email: {
        type: DataTypes.STRING,
        allowNull: false,
        unique: true,
        validate: { isEmail: true },
      },
      password: {
        type: DataTypes.STRING,
        allowNull: false,
      },
      avatar: {
        type: DataTypes.STRING,
        defaultValue: "https://via.placeholder.com/150",
      },
    },
    {
      sequelize,
      modelName: "User",
    },
  );

  return User;
};
</file>

<file path="backend/lib/cloudinary.js">
const cloudinary = require("cloudinary").v2;
const { CloudinaryStorage } = require("multer-storage-cloudinary");
const multer = require("multer");
require("dotenv").config();

// 1. Configure Cloudinary
cloudinary.config({
  cloud_name: process.env.CLOUDINARY_CLOUD_NAME,
  api_key: process.env.CLOUDINARY_API_KEY,
  api_secret: process.env.CLOUDINARY_API_SECRET,
});

// 2. Configure Storage Engine
const storage = new CloudinaryStorage({
  cloudinary: cloudinary,
  params: {
    folder: "nexus_chat_uploads", // Folder name in your Cloudinary console
    allowed_formats: ["jpg", "png", "jpeg", "gif"], // Allowed file types
  },
});

// 3. Initialize Multer
const upload = multer({ storage: storage });

module.exports = { upload, cloudinary };
</file>

<file path="backend/lib/queue.js">
const { Queue } = require("bullmq");
require("dotenv").config();

// Configuration for Redis connection
const connection = {
  host: process.env.REDIS_HOST || "127.0.0.1",
  port: process.env.REDIS_PORT || 6379,
};

// Create the Queue instance
const messageQueue = new Queue("chat-messages", { connection });

module.exports = { messageQueue, connection };
</file>

<file path="backend/lib/rateLimiter.js">
const { RateLimiterRedis } = require("rate-limiter-flexible");
const { createClient } = require("redis");
require("dotenv").config();

// Create a dedicated Redis client for Rate Limiting
const rateLimiterClient = createClient({
  url: process.env.REDIS_URL || "redis://127.0.0.1:6379",
  enableOfflineQueue: false, // Recommended for Rate Limiters
});

rateLimiterClient.on("error", (err) =>
  console.error("‚ùå RateLimit Redis Error", err),
);

// Connect immediately
(async () => {
  try {
    await rateLimiterClient.connect();
    console.log("‚úÖ Rate Limiter Redis Connected");
  } catch (err) {
    console.error("‚ùå Failed to connect Rate Limiter Redis", err);
  }
})();

// 1. Auth Limiter (Strict)
const authLimiter = new RateLimiterRedis({
  storeClient: rateLimiterClient,
  keyPrefix: "middleware:auth",
  points: 10,
  duration: 15 * 60,
});

// 2. Upload Limiter (Moderate)
const uploadLimiter = new RateLimiterRedis({
  storeClient: rateLimiterClient,
  keyPrefix: "middleware:upload",
  points: 10,
  duration: 60,
});

// 3. Socket Message Limiter (Relaxed for Dev)
const socketLimiter = new RateLimiterRedis({
  storeClient: rateLimiterClient,
  keyPrefix: "middleware:socket",
  points: 20,
  duration: 60,
});

module.exports = { authLimiter, uploadLimiter, socketLimiter };
</file>

<file path="backend/lib/redis.js">
const { createClient } = require("redis");
require("dotenv").config();

const redisClient = createClient({
  url: process.env.REDIS_URL || "redis://127.0.0.1:6379",
});

redisClient.on("error", (err) => console.log("‚ùå Redis Client Error", err));

// Connect immediately
(async () => {
  if (!redisClient.isOpen) {
    await redisClient.connect();
    console.log("‚úÖ Redis Client Connected for Caching");

    // --- NEW: Clear DB on startup (Dev only) ---
    // This fixes the "I waited 24h but still blocked" issue
    if (process.env.NODE_ENV === "development") {
      await redisClient.flushAll();
      console.log("üßπ Redis Database Flushed (Clean Start)");
    }
  }
})();

module.exports = redisClient;
</file>

<file path="backend/routes/auth.js">
const express = require("express");
const router = express.Router();
const authController = require("../controllers/authController");
const { authLimiter } = require("../lib/rateLimiter");

// Destructure cleanly
const { register, login } = authController;

// Middleware Wrapper for HTTP
const rateLimitMiddleware = (limiter) => async (req, res, next) => {
  try {
    if (limiter) {
      await limiter.consume(req.ip);
    }
    next();
  } catch (rejRes) {
    res.status(429).json({ message: "Too many attempts. Try again later." });
  }
};

// Debug Check
if (!register || !login) {
  console.error("‚ùå CRITICAL ERROR: Auth Controller functions are missing!");
}

// --- BYPASS RATE LIMITER FOR DEV ---
// passing 'null' or removing the middleware wrapper effectively disables it
router.post("/register", register); // <--- REMOVED rateLimitMiddleware
router.post("/login", login); // <--- REMOVED rateLimitMiddleware

module.exports = router;
</file>

<file path="backend/routes/upload.js">
const express = require("express");
const router = express.Router();
const { upload } = require("../lib/cloudinary");

// POST /api/upload
// 'file' must match the key name used in Frontend FormData
router.post("/", upload.single("file"), (req, res) => {
  try {
    if (!req.file) {
      return res.status(400).json({ message: "No file uploaded" });
    }

    // Multer + Cloudinary automatically puts the URL here:
    res.json({
      message: "Upload successful",
      url: req.file.path, // The remote Cloudinary URL
    });
  } catch (error) {
    console.error("Upload error:", error);
    res.status(500).json({ message: "Server error during upload" });
  }
});

module.exports = router;
</file>

<file path="backend/sockets/index.js">
const { Server } = require("socket.io");
const { createAdapter } = require("@socket.io/redis-adapter");
const { createClient } = require("redis");
const redisClient = require("../lib/redis");
const { messageQueue } = require("../lib/queue");
const { socketLimiter } = require("../lib/rateLimiter");

module.exports = async (httpServer) => {
  const pubClient = createClient({ url: "redis://127.0.0.1:6379" });
  const subClient = pubClient.duplicate();
  await Promise.all([pubClient.connect(), subClient.connect()]);

  const io = new Server(httpServer, {
    cors: {
      origin: "http://localhost:5173",
      methods: ["GET", "POST"],
    },
    adapter: createAdapter(pubClient, subClient),
  });

  // Map to store userId -> socketId
  const onlineUsers = new Map();

  io.on("connection", (socket) => {
    console.log(`‚úÖ User Connected: ${socket.id}`);

    socket.on("user_connected", (userId) => {
      onlineUsers.set(userId, socket.id);
      socket.data.userId = userId;
      io.emit("update_online_users", Array.from(onlineUsers.keys()));
    });

    socket.on("join_channel", (channelId) => {
      socket.join(channelId);
    });

    // --- WEBRTC SIGNALING EVENTS ---

    // 1. Caller initiates call
    socket.on("call_user", (data) => {
      // data: { userToCall, signalData, from, name }
      const socketIdToCall = onlineUsers.get(data.userToCall);
      if (socketIdToCall) {
        io.to(socketIdToCall).emit("call_user", {
          signal: data.signalData,
          from: data.from,
          name: data.name,
        });
      }
    });

    // 2. Callee accepts call
    socket.on("answer_call", (data) => {
      // data: { to, signal }
      const socketIdToAnswer = onlineUsers.get(data.to);
      if (socketIdToAnswer) {
        io.to(socketIdToAnswer).emit("call_accepted", data.signal);
      }
    });

    // 3. Exchange ICE Candidates (Network paths)
    socket.on("ice_candidate", (data) => {
      // data: { to, candidate }
      const socketId = onlineUsers.get(data.to);
      if (socketId) {
        io.to(socketId).emit("ice_candidate", data.candidate);
      }
    });

    // 4. End Call
    socket.on("end_call", (data) => {
      const socketId = onlineUsers.get(data.to);
      if (socketId) {
        io.to(socketId).emit("call_ended");
      }
    });

    // --- EXISTING EVENTS ---

    socket.on("mark_read", async ({ channelId, messageId, userId }) => {
      if (!channelId || !messageId || !userId) return;
      const key = `receipt:channel:${channelId}:user:${userId}`;
      const currentRead = await redisClient.get(key);
      if (!currentRead || parseInt(messageId) > parseInt(currentRead)) {
        await redisClient.set(key, messageId);
        io.to(channelId).emit("user_read_update", {
          userId,
          channelId,
          lastReadMessageId: messageId,
        });
      }
    });

    socket.on("typing", (data) => {
      socket.to(data.channelId).emit("user_typing", data.username);
    });

    socket.on("stop_typing", (data) => {
      socket.to(data.channelId).emit("user_stop_typing", data.username);
    });

    socket.on("message_reaction", (data) => {
      io.to(data.channelId).emit("message_reaction_update", {
        messageId: data.messageId,
        userId: data.userId,
        emoji: data.emoji,
      });
    });

    socket.on("send_message", async (data) => {
      try {
        const limiterKey = data.senderId || socket.id;
        try {
          await socketLimiter.consume(limiterKey);
        } catch (limiterError) {
          if (limiterError instanceof Error) {
            console.error("Rate Limit Error:", limiterError.message);
          }
        }

        console.log(
          `üì• Received Msg for ${data.channelId}, adding to Queue...`,
        );

        await messageQueue.add("process_message", {
          content: data.content,
          senderId: data.senderId,
          channelId: data.channelId,
          attachmentUrl: data.attachmentUrl,
          tempId: data.tempId,
        });

        socket.emit("message_queued", { status: "queued" });
      } catch (rejRes) {
        const timeToWait = Math.round(rejRes.msBeforeNext / 1000) || 1;
        socket.emit("message_error", {
          error: `Sending too fast! Wait ${timeToWait} seconds.`,
        });
      }
    });

    socket.on("disconnect", () => {
      for (const [userId, socketId] of onlineUsers.entries()) {
        if (socketId === socket.id) {
          onlineUsers.delete(userId);
          break;
        }
      }
      io.emit("update_online_users", Array.from(onlineUsers.keys()));
    });
  });

  return io;
};
</file>

<file path="backend/workers/chatWorker.js">
const { Worker } = require("bullmq");
const { connection } = require("../lib/queue");
const { Message, User } = require("../db/models");
const redisClient = require("../lib/redis");

const initWorker = (io) => {
  const worker = new Worker(
    "chat-messages",
    async (job) => {
      // Extract tempId
      const { content, senderId, channelId, attachmentUrl, tempId } = job.data;
      console.log(
        `‚öôÔ∏è Worker Processing: Message from ${senderId} in ${channelId}`,
      );

      try {
        // 1. DATABASE WRITE
        const newMessage = await Message.create({
          content: content || "",
          senderId,
          conversationId: channelId,
          attachmentUrl: attachmentUrl || null,
        });

        // 2. FETCH DETAILS
        const fullMessage = await Message.findOne({
          where: { id: newMessage.id },
          include: [
            { model: User, as: "sender", attributes: ["username", "avatar"] },
          ],
        });

        // 3. PREPARE PAYLOAD
        const broadcastData = {
          id: fullMessage.id,
          content: fullMessage.content,
          attachmentUrl: fullMessage.attachmentUrl,
          sender: fullMessage.sender.username,
          senderId: fullMessage.senderId,
          time: new Date(fullMessage.createdAt).toLocaleTimeString([], {
            hour: "2-digit",
            minute: "2-digit",
          }),
          channelId: channelId,
          avatar: fullMessage.sender.avatar,
          reactions: [],
          tempId: tempId, // <--- Send back to client
        };

        // 4. CACHE UPDATE
        const cacheKey = `messages:channel:${channelId}`;
        const cacheExists = await redisClient.exists(cacheKey);

        if (cacheExists) {
          await redisClient.lPush(cacheKey, JSON.stringify(broadcastData));
          await redisClient.lTrim(cacheKey, 0, 49);
        }

        // 5. BROADCAST
        io.to(channelId).emit("receive_message", broadcastData);

        console.log(`‚úÖ Worker Completed: Msg ${newMessage.id}`);
        return broadcastData;
      } catch (err) {
        console.error("‚ùå Worker Failed:", err);
        throw err;
      }
    },
    { connection },
  );

  worker.on("failed", (job, err) => {
    console.error(`Job ${job.id} failed: ${err.message}`);
  });

  console.log("üë∑ Chat Worker Started");
};

module.exports = initWorker;
</file>

<file path="backend/workers/receiptWorker.js">
const { ConversationParticipant } = require("../db/models");
const redisClient = require("../lib/redis");

// How often to sync to DB (ms)
const FLUSH_INTERVAL = 10000;

const initReceiptWorker = () => {
  console.log("üëÄ Receipt Worker Started (Write-Behind Strategy)");

  setInterval(async () => {
    try {
      // 1. Get all "dirty" keys (users who have updated their read status)
      // We store keys as: "receipt:channel:{channelId}:user:{userId}"
      const keys = await redisClient.keys("receipt:channel:*:user:*");

      if (keys.length === 0) return;

      const updates = [];

      // 2. Gather values from Redis
      for (const key of keys) {
        const lastReadMessageId = await redisClient.get(key);
        if (!lastReadMessageId) continue;

        // Parse key: "receipt:channel:1:user:5"
        const parts = key.split(":");
        const channelId = parts[2];
        const userId = parts[4];

        updates.push({
          userId,
          conversationId: channelId,
          lastReadMessageId,
          key, // Keep key to delete later
        });
      }

      if (updates.length === 0) return;

      console.log(`üíæ Flushing ${updates.length} read receipts to DB...`);

      // 3. Batch Upsert to Database
      // We loop because Sequelize bulkCreate with updateOnDuplicate is tricky across dialects
      // For safety and simplicity in this setup, we iterate.
      // In high-scale prod, you'd use a raw SQL "INSERT ... ON CONFLICT" query.
      for (const update of updates) {
        await ConversationParticipant.upsert({
          userId: update.userId,
          conversationId: update.conversationId,
          lastReadMessageId: update.lastReadMessageId,
        });

        // 4. Remove from Redis (Clean the buffer)
        // Only delete if DB write succeeded
        await redisClient.del(update.key);
      }
    } catch (error) {
      console.error("‚ùå Receipt Flush Error:", error);
    }
  }, FLUSH_INTERVAL);
};

module.exports = initReceiptWorker;
</file>

<file path="backend/.sequelizerc">
const path = require('path');

module.exports = {
  'config': path.resolve('config', 'database.js'),
  'models-path': path.resolve('db', 'models'),
  'seeders-path': path.resolve('db', 'seeders'),
  'migrations-path': path.resolve('db', 'migrations')
};
</file>

<file path="backend/package.json">
{
  "name": "backend",
  "version": "1.0.0",
  "description": "",
  "main": "server.js",
  "scripts": {
    "start": "node server.js",
    "dev": "npx kill-port 5001 && nodemon server.js",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "type": "commonjs",
  "dependencies": {
    "@socket.io/redis-adapter": "^8.3.0",
    "bcryptjs": "^3.0.3",
    "bullmq": "^5.69.2",
    "cloudinary": "^2.9.0",
    "cors": "^2.8.6",
    "dotenv": "^17.3.1",
    "express": "^5.2.1",
    "helmet": "^8.1.0",
    "jsonwebtoken": "^9.0.3",
    "morgan": "^1.10.1",
    "multer": "^2.0.2",
    "multer-storage-cloudinary": "^4.0.0",
    "pg": "^8.18.0",
    "pg-hstore": "^2.3.4",
    "rate-limiter-flexible": "^9.1.1",
    "redis": "^5.10.0",
    "sequelize": "^6.37.7",
    "socket.io": "^4.8.3"
  },
  "devDependencies": {
    "nodemon": "^3.1.11",
    "sequelize-cli": "^6.6.5"
  }
}
</file>

<file path="backend/server.js">
const dotenv = require("dotenv");
dotenv.config(); // <--- MOVE THIS TO THE TOP (Line 1 & 2)

const express = require("express");
const http = require("http");
const cors = require("cors");
// const dotenv = require("dotenv"); // <--- DELETE THIS LINE (Moved up)
const db = require("./db/models");
const initSocket = require("./sockets");
const authRoutes = require("./routes/auth");
const uploadRoutes = require("./routes/upload");
const initWorker = require("./workers/chatWorker");
const initReceiptWorker = require("./workers/receiptWorker");

const {
  getMessages,
  reactToMessage,
  searchMessages,
} = require("./controllers/messageController");

// dotenv.config(); // <--- DELETE THIS LINE (Moved up)

const app = express();
const server = http.createServer(app);

app.use(cors());
app.use(express.json());

app.use("/api/auth", authRoutes);
app.use("/api/upload", uploadRoutes);

// Messages Routes
app.get("/api/messages/:channelId/search", searchMessages);
app.get("/api/messages/:channelId", getMessages);
app.post("/api/messages/:messageId/react", reactToMessage);

const PORT = process.env.PORT || 5001;

initSocket(server).then((io) => {
  app.set("socketio", io);

  // Start Background Workers
  initWorker(io);
  initReceiptWorker();

  db.sequelize
    .authenticate()
    .then(() => {
      console.log("‚úÖ Database connected successfully.");
      server.listen(PORT, () => {
        console.log(`üöÄ Server running on port ${PORT}`);
      });
    })
    .catch((err) => {
      console.error("‚ùå Unable to connect to the database:", err);
    });
});
</file>

<file path="frontend/public/vite.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>
</file>

<file path="frontend/src/api/axios.js">
import axios from "axios";

const api = axios.create({
  baseURL: "http://localhost:5001/api", // Matches your backend URL
});

// Automatically add token to requests if it exists
api.interceptors.request.use((config) => {
  const token = localStorage.getItem("token");
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
});

export default api;
</file>

<file path="frontend/src/assets/react.svg">
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="35.93" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 228"><path fill="#00D8FF" d="M210.483 73.824a171.49 171.49 0 0 0-8.24-2.597c.465-1.9.893-3.777 1.273-5.621c6.238-30.281 2.16-54.676-11.769-62.708c-13.355-7.7-35.196.329-57.254 19.526a171.23 171.23 0 0 0-6.375 5.848a155.866 155.866 0 0 0-4.241-3.917C100.759 3.829 77.587-4.822 63.673 3.233C50.33 10.957 46.379 33.89 51.995 62.588a170.974 170.974 0 0 0 1.892 8.48c-3.28.932-6.445 1.924-9.474 2.98C17.309 83.498 0 98.307 0 113.668c0 15.865 18.582 31.778 46.812 41.427a145.52 145.52 0 0 0 6.921 2.165a167.467 167.467 0 0 0-2.01 9.138c-5.354 28.2-1.173 50.591 12.134 58.266c13.744 7.926 36.812-.22 59.273-19.855a145.567 145.567 0 0 0 5.342-4.923a168.064 168.064 0 0 0 6.92 6.314c21.758 18.722 43.246 26.282 56.54 18.586c13.731-7.949 18.194-32.003 12.4-61.268a145.016 145.016 0 0 0-1.535-6.842c1.62-.48 3.21-.974 4.76-1.488c29.348-9.723 48.443-25.443 48.443-41.52c0-15.417-17.868-30.326-45.517-39.844Zm-6.365 70.984c-1.4.463-2.836.91-4.3 1.345c-3.24-10.257-7.612-21.163-12.963-32.432c5.106-11 9.31-21.767 12.459-31.957c2.619.758 5.16 1.557 7.61 2.4c23.69 8.156 38.14 20.213 38.14 29.504c0 9.896-15.606 22.743-40.946 31.14Zm-10.514 20.834c2.562 12.94 2.927 24.64 1.23 33.787c-1.524 8.219-4.59 13.698-8.382 15.893c-8.067 4.67-25.32-1.4-43.927-17.412a156.726 156.726 0 0 1-6.437-5.87c7.214-7.889 14.423-17.06 21.459-27.246c12.376-1.098 24.068-2.894 34.671-5.345a134.17 134.17 0 0 1 1.386 6.193ZM87.276 214.515c-7.882 2.783-14.16 2.863-17.955.675c-8.075-4.657-11.432-22.636-6.853-46.752a156.923 156.923 0 0 1 1.869-8.499c10.486 2.32 22.093 3.988 34.498 4.994c7.084 9.967 14.501 19.128 21.976 27.15a134.668 134.668 0 0 1-4.877 4.492c-9.933 8.682-19.886 14.842-28.658 17.94ZM50.35 144.747c-12.483-4.267-22.792-9.812-29.858-15.863c-6.35-5.437-9.555-10.836-9.555-15.216c0-9.322 13.897-21.212 37.076-29.293c2.813-.98 5.757-1.905 8.812-2.773c3.204 10.42 7.406 21.315 12.477 32.332c-5.137 11.18-9.399 22.249-12.634 32.792a134.718 134.718 0 0 1-6.318-1.979Zm12.378-84.26c-4.811-24.587-1.616-43.134 6.425-47.789c8.564-4.958 27.502 2.111 47.463 19.835a144.318 144.318 0 0 1 3.841 3.545c-7.438 7.987-14.787 17.08-21.808 26.988c-12.04 1.116-23.565 2.908-34.161 5.309a160.342 160.342 0 0 1-1.76-7.887Zm110.427 27.268a347.8 347.8 0 0 0-7.785-12.803c8.168 1.033 15.994 2.404 23.343 4.08c-2.206 7.072-4.956 14.465-8.193 22.045a381.151 381.151 0 0 0-7.365-13.322Zm-45.032-43.861c5.044 5.465 10.096 11.566 15.065 18.186a322.04 322.04 0 0 0-30.257-.006c4.974-6.559 10.069-12.652 15.192-18.18ZM82.802 87.83a323.167 323.167 0 0 0-7.227 13.238c-3.184-7.553-5.909-14.98-8.134-22.152c7.304-1.634 15.093-2.97 23.209-3.984a321.524 321.524 0 0 0-7.848 12.897Zm8.081 65.352c-8.385-.936-16.291-2.203-23.593-3.793c2.26-7.3 5.045-14.885 8.298-22.6a321.187 321.187 0 0 0 7.257 13.246c2.594 4.48 5.28 8.868 8.038 13.147Zm37.542 31.03c-5.184-5.592-10.354-11.779-15.403-18.433c4.902.192 9.899.29 14.978.29c5.218 0 10.376-.117 15.453-.343c-4.985 6.774-10.018 12.97-15.028 18.486Zm52.198-57.817c3.422 7.8 6.306 15.345 8.596 22.52c-7.422 1.694-15.436 3.058-23.88 4.071a382.417 382.417 0 0 0 7.859-13.026a347.403 347.403 0 0 0 7.425-13.565Zm-16.898 8.101a358.557 358.557 0 0 1-12.281 19.815a329.4 329.4 0 0 1-23.444.823c-7.967 0-15.716-.248-23.178-.732a310.202 310.202 0 0 1-12.513-19.846h.001a307.41 307.41 0 0 1-10.923-20.627a310.278 310.278 0 0 1 10.89-20.637l-.001.001a307.318 307.318 0 0 1 12.413-19.761c7.613-.576 15.42-.876 23.31-.876H128c7.926 0 15.743.303 23.354.883a329.357 329.357 0 0 1 12.335 19.695a358.489 358.489 0 0 1 11.036 20.54a329.472 329.472 0 0 1-11 20.722Zm22.56-122.124c8.572 4.944 11.906 24.881 6.52 51.026c-.344 1.668-.73 3.367-1.15 5.09c-10.622-2.452-22.155-4.275-34.23-5.408c-7.034-10.017-14.323-19.124-21.64-27.008a160.789 160.789 0 0 1 5.888-5.4c18.9-16.447 36.564-22.941 44.612-18.3ZM128 90.808c12.625 0 22.86 10.235 22.86 22.86s-10.235 22.86-22.86 22.86s-22.86-10.235-22.86-22.86s10.235-22.86 22.86-22.86Z"></path></svg>
</file>

<file path="frontend/src/lib/socket.js">
import { io } from "socket.io-client";

// Connect to backend URL
export const socket = io("http://localhost:5001", {
  autoConnect: false, // We connect manually when user logs in
});
</file>

<file path="frontend/src/pages/Chat.jsx">
import { useEffect, useState, useRef, useCallback } from "react";
import { useAuthStore } from "../store/useAuthStore";
import { socket } from "../lib/socket";
import api from "../api/axios";
import { useNavigate } from "react-router-dom";
import { motion, AnimatePresence } from "framer-motion";
import toast, { Toaster } from "react-hot-toast";
import {
  Send,
  Hash,
  LogOut,
  Menu,
  MessageSquare,
  Users,
  Paperclip,
  X,
  Loader2,
  Smile,
  Search,
  ArrowLeft,
  Check,
  CheckCheck,
  Maximize2,
  Video,
  Phone,
  PhoneOff,
  Mic,
  MicOff,
  Camera,
  CameraOff,
} from "lucide-react";

// --- WEBRTC CONFIG ---
const rtcConfig = {
  iceServers: [
    { urls: "stun:stun.l.google.com:19302" }, // Public Google STUN server
    { urls: "stun:global.stun.twilio.com:3478" },
  ],
};

const Chat = () => {
  const { user, logout } = useAuthStore();
  const navigate = useNavigate();

  // -- Chat State --
  const [messages, setMessages] = useState([]);
  const [readStatus, setReadStatus] = useState({});
  const [currentMessage, setCurrentMessage] = useState("");
  const [isConnected, setIsConnected] = useState(false);
  const [onlineUserIds, setOnlineUserIds] = useState([]);
  const [typingUsers, setTypingUsers] = useState([]);
  const [isSidebarOpen, setIsSidebarOpen] = useState(false);

  const [isSearchOpen, setIsSearchOpen] = useState(false);
  const [searchQuery, setSearchQuery] = useState("");
  const [isSearching, setIsSearching] = useState(false);

  const [selectedFile, setSelectedFile] = useState(null);
  const [isUploading, setIsUploading] = useState(false);
  const fileInputRef = useRef(null);

  // Lightbox State
  const [lightboxImage, setLightboxImage] = useState(null);

  const [page, setPage] = useState(1);
  const [hasMore, setHasMore] = useState(true);
  const [isFetchingOld, setIsFetchingOld] = useState(false);
  const [isLoadingInitial, setIsLoadingInitial] = useState(false);

  // -- VIDEO CALL STATE --
  const [callStatus, setCallStatus] = useState("idle"); // idle, calling, receiving, connected
  const [callData, setCallData] = useState(null); // { from, signal, name }
  const [localStream, setLocalStream] = useState(null);
  const [remoteStream, setRemoteStream] = useState(null);
  const [isMicMuted, setIsMicMuted] = useState(false);
  const [isVideoOff, setIsVideoOff] = useState(false);

  // Refs
  const messagesContainerRef = useRef(null);
  const messagesEndRef = useRef(null);
  const typingTimeoutRef = useRef(null);
  const searchTimeoutRef = useRef(null);
  const observerRef = useRef(null);

  // WebRTC Refs
  const localVideoRef = useRef(null);
  const remoteVideoRef = useRef(null);
  const peerConnectionRef = useRef(null);
  const activeCallUserRef = useRef(null); // ID of user we are talking to

  const [activeReactionMessageId, setActiveReactionMessageId] = useState(null);

  const channels = [
    { id: 1, name: "general" },
    { id: 2, name: "react-help" },
    { id: 3, name: "random" },
  ];
  const [activeChannel, setActiveChannel] = useState(channels[0]);

  // -- HELPER: Fetch Messages --
  const fetchMessages = useCallback(
    async (reset = false) => {
      if (isSearchOpen) return;
      if (reset) setIsLoadingInitial(true);
      try {
        const targetPage = reset ? 1 : page;
        const res = await api.get(
          `/messages/${activeChannel.id}?page=${targetPage}`,
        );
        const fetchedMsgs = res.data.messages || [];
        if (res.data.readStatus) setReadStatus(res.data.readStatus);
        if (reset) {
          setMessages(fetchedMsgs);
          setPage(1);
        } else {
          setMessages((prev) => [...fetchedMsgs, ...prev]);
        }
        setHasMore(res.data.hasMore);
      } catch (err) {
        toast.error("Failed to load messages", err);
      } finally {
        if (reset) setIsLoadingInitial(false);
      }
    },
    [activeChannel.id, page, isSearchOpen],
  );

  // -- OBSERVER --
  const setupObserver = () => {
    if (observerRef.current) observerRef.current.disconnect();
    observerRef.current = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            const msgId = entry.target.getAttribute("data-msg-id");
            if (msgId && user) {
              socket.emit("mark_read", {
                channelId: activeChannel.id,
                messageId: msgId,
                userId: user.id,
              });
            }
          }
        });
      },
      { threshold: 0.5 },
    );
    const msgElements = document.querySelectorAll(".message-item");
    if (msgElements.length > 0)
      observerRef.current.observe(msgElements[msgElements.length - 1]);
  };

  useEffect(() => {
    if (!isFetchingOld && messages.length > 0) setupObserver();
  }, [messages, isFetchingOld]);

  // -- EFFECTS --
  useEffect(() => {
    if (!isSearchOpen) fetchMessages(true);
    setTypingUsers([]);
    setSelectedFile(null);
  }, [activeChannel, isSearchOpen, fetchMessages]);

  useEffect(() => {
    if (!isFetchingOld && !isSearchOpen) {
      messagesEndRef.current?.scrollIntoView({ behavior: "smooth" });
    }
  }, [messages.length, typingUsers, activeChannel, isSearchOpen]);

  const handleScroll = async () => {
    if (isSearchOpen) return;
    const container = messagesContainerRef.current;
    if (!container) return;
    if (container.scrollTop === 0 && hasMore && !isFetchingOld) {
      setIsFetchingOld(true);
      const previousHeight = container.scrollHeight;
      setPage((prev) => prev + 1);
      try {
        const nextPage = page + 1;
        const res = await api.get(
          `/messages/${activeChannel.id}?page=${nextPage}`,
        );
        const newMsgs = res.data.messages || [];
        if (newMsgs.length > 0) {
          setMessages((prev) => [...newMsgs, ...prev]);
          setHasMore(res.data.hasMore);
          setTimeout(() => {
            const newHeight = container.scrollHeight;
            container.scrollTop = newHeight - previousHeight;
          }, 0);
        } else {
          setHasMore(false);
        }
      } catch (err) {
        toast.error("Could not load older messages", err);
      } finally {
        setIsFetchingOld(false);
      }
    }
  };

  // -------------------------
  // WEBRTC LOGIC
  // -------------------------

  // 1. Start Call (Initiator)
  const startCall = async (userToCallId) => {
    setCallStatus("calling");
    activeCallUserRef.current = userToCallId;

    try {
      const stream = await navigator.mediaDevices.getUserMedia({
        video: true,
        audio: true,
      });
      setLocalStream(stream);
      if (localVideoRef.current) localVideoRef.current.srcObject = stream;

      const peer = new RTCPeerConnection(rtcConfig);
      peerConnectionRef.current = peer;

      // Add Tracks
      stream.getTracks().forEach((track) => peer.addTrack(track, stream));

      // Handle ICE Candidates
      peer.onicecandidate = (event) => {
        if (event.candidate) {
          socket.emit("ice_candidate", {
            to: userToCallId,
            candidate: event.candidate,
          });
        }
      };

      // Handle Remote Stream
      peer.ontrack = (event) => {
        setRemoteStream(event.streams[0]);
        if (remoteVideoRef.current)
          remoteVideoRef.current.srcObject = event.streams[0];
      };

      // Create Offer
      const offer = await peer.createOffer();
      await peer.setLocalDescription(offer);

      socket.emit("call_user", {
        userToCall: userToCallId,
        signalData: offer,
        from: user.id,
        name: user.username,
      });
    } catch (err) {
      console.error("Error starting call:", err);
      toast.error("Could not access camera/microphone");
      setCallStatus("idle");
    }
  };

  // 2. Answer Call (Receiver)
  const answerCall = async () => {
    setCallStatus("connected");
    const callerId = callData.from;
    activeCallUserRef.current = callerId;

    try {
      const stream = await navigator.mediaDevices.getUserMedia({
        video: true,
        audio: true,
      });
      setLocalStream(stream);
      if (localVideoRef.current) localVideoRef.current.srcObject = stream;

      const peer = new RTCPeerConnection(rtcConfig);
      peerConnectionRef.current = peer;

      stream.getTracks().forEach((track) => peer.addTrack(track, stream));

      peer.onicecandidate = (event) => {
        if (event.candidate) {
          socket.emit("ice_candidate", {
            to: callerId,
            candidate: event.candidate,
          });
        }
      };

      peer.ontrack = (event) => {
        setRemoteStream(event.streams[0]);
        if (remoteVideoRef.current)
          remoteVideoRef.current.srcObject = event.streams[0];
      };

      await peer.setRemoteDescription(
        new RTCSessionDescription(callData.signal),
      );
      const answer = await peer.createAnswer();
      await peer.setLocalDescription(answer);

      socket.emit("answer_call", { signal: answer, to: callerId });
    } catch (err) {
      console.error("Error answering call:", err);
      endCall();
    }
  };

  // 3. End Call
  const endCall = () => {
    if (peerConnectionRef.current) {
      peerConnectionRef.current.close();
      peerConnectionRef.current = null;
    }
    if (localStream) {
      localStream.getTracks().forEach((track) => track.stop());
      setLocalStream(null);
    }
    if (activeCallUserRef.current) {
      socket.emit("end_call", { to: activeCallUserRef.current });
    }

    setRemoteStream(null);
    setCallStatus("idle");
    setCallData(null);
    activeCallUserRef.current = null;
  };

  const toggleMic = () => {
    if (localStream) {
      localStream
        .getAudioTracks()
        .forEach((track) => (track.enabled = !track.enabled));
      setIsMicMuted(!isMicMuted);
    }
  };

  const toggleVideo = () => {
    if (localStream) {
      localStream
        .getVideoTracks()
        .forEach((track) => (track.enabled = !track.enabled));
      setIsVideoOff(!isVideoOff);
    }
  };

  // Attach local stream to video element when it mounts/updates
  useEffect(() => {
    if (localVideoRef.current && localStream) {
      localVideoRef.current.srcObject = localStream;
    }
  }, [localStream, callStatus]);

  useEffect(() => {
    if (remoteVideoRef.current && remoteStream) {
      remoteVideoRef.current.srcObject = remoteStream;
    }
  }, [remoteStream, callStatus]);

  // -- SOCKET LOGIC --
  useEffect(() => {
    if (!user) {
      navigate("/login");
      return;
    }
    socket.connect();
    socket.emit("user_connected", user.id);
    socket.emit("join_channel", activeChannel.id);

    function onConnect() {
      setIsConnected(true);
    }
    function onDisconnect() {
      setIsConnected(false);
    }

    // --- WebRTC Socket Events ---
    function onCallUser(data) {
      // Incoming call
      setCallData(data);
      setCallStatus("receiving");
    }

    function onCallAccepted(signal) {
      setCallStatus("connected");
      if (peerConnectionRef.current) {
        peerConnectionRef.current.setRemoteDescription(
          new RTCSessionDescription(signal),
        );
      }
    }

    function onIceCandidate(candidate) {
      if (peerConnectionRef.current) {
        peerConnectionRef.current.addIceCandidate(
          new RTCIceCandidate(candidate),
        );
      }
    }

    function onCallEnded() {
      endCall();
      toast.success("Call ended");
    }

    // --- Standard Chat Events ---
    function onReceiveMessage(newMessage) {
      if (newMessage.channelId === activeChannel.id && !isSearchOpen) {
        setMessages((prev) => {
          const tempIndex = prev.findIndex(
            (m) => m.tempId && m.tempId === newMessage.tempId,
          );
          if (tempIndex !== -1) {
            const updated = [...prev];
            updated[tempIndex] = newMessage;
            return updated;
          }
          if (prev.some((m) => m.id === newMessage.id)) return prev;
          return [...prev, newMessage];
        });
        setTimeout(
          () => messagesEndRef.current?.scrollIntoView({ behavior: "smooth" }),
          100,
        );
      }
    }

    function onUserReadUpdate(data) {
      setReadStatus((prev) => ({
        ...prev,
        [data.userId]: data.lastReadMessageId,
      }));
    }

    function onMessageError(data) {
      toast.error(data.error);
      if (!isSearchOpen) fetchMessages(true);
    }

    function onUpdateOnlineUsers(userIds) {
      setOnlineUserIds(userIds);
    }
    function onUserTyping(username) {
      setTypingUsers((prev) =>
        prev.includes(username) ? prev : [...prev, username],
      );
    }
    function onUserStopTyping(username) {
      setTypingUsers((prev) => prev.filter((u) => u !== username));
    }
    function onReactionUpdate({ messageId, userId, emoji }) {
      setMessages((prev) =>
        prev.map((msg) => {
          if (msg.id !== messageId) return msg;
          const current = msg.reactions || [];
          const idx = current.findIndex(
            (r) => r.userId === userId && r.emoji === emoji,
          );
          let updated = [...current];
          if (idx > -1) updated.splice(idx, 1);
          else updated.push({ userId, emoji });
          return { ...msg, reactions: updated };
        }),
      );
    }

    socket.on("connect", onConnect);
    socket.on("disconnect", onDisconnect);
    socket.on("receive_message", onReceiveMessage);
    socket.on("user_read_update", onUserReadUpdate);
    socket.on("message_error", onMessageError);
    socket.on("update_online_users", onUpdateOnlineUsers);
    socket.on("user_typing", onUserTyping);
    socket.on("user_stop_typing", onUserStopTyping);
    socket.on("message_reaction_update", onReactionUpdate);

    // WebRTC Listeners
    socket.on("call_user", onCallUser);
    socket.on("call_accepted", onCallAccepted);
    socket.on("ice_candidate", onIceCandidate);
    socket.on("call_ended", onCallEnded);

    return () => {
      socket.off("connect", onConnect);
      socket.off("disconnect", onDisconnect);
      socket.off("receive_message", onReceiveMessage);
      socket.off("user_read_update", onUserReadUpdate);
      socket.off("message_error", onMessageError);
      socket.off("update_online_users", onUpdateOnlineUsers);
      socket.off("user_typing", onUserTyping);
      socket.off("user_stop_typing", onUserStopTyping);
      socket.off("message_reaction_update", onReactionUpdate);
      socket.off("call_user", onCallUser);
      socket.off("call_accepted", onCallAccepted);
      socket.off("ice_candidate", onIceCandidate);
      socket.off("call_ended", onCallEnded);
    };
  }, [user, navigate, activeChannel, isSearchOpen, fetchMessages]);

  // ... (Rest of handlers: handleSendMessage, handleReaction, etc. remain the same) ...
  const handleSendMessage = async (e) => {
    e.preventDefault();
    if ((!currentMessage.trim() && !selectedFile) || !user || isUploading)
      return;
    let attachmentUrl = null;
    if (selectedFile) {
      setIsUploading(true);
      const loadingToast = toast.loading("Uploading image...");
      try {
        const formData = new FormData();
        formData.append("file", selectedFile);
        const res = await api.post("/upload", formData, {
          headers: { "Content-Type": "multipart/form-data" },
        });
        attachmentUrl = res.data.url;
        toast.dismiss(loadingToast);
      } catch (error) {
        toast.dismiss(loadingToast);
        toast.error("Upload failed", error);
        setIsUploading(false);
        return;
      } finally {
        setIsUploading(false);
      }
    }
    const tempId = Date.now() + Math.random();
    const messageData = {
      channelId: activeChannel.id,
      content: currentMessage,
      senderId: user.id,
      sender: user.username,
      time: new Date().toLocaleTimeString([], {
        hour: "2-digit",
        minute: "2-digit",
      }),
      attachmentUrl: attachmentUrl,
      reactions: [],
      tempId: tempId,
    };
    socket.emit("send_message", messageData);
    setMessages((prev) => [...prev, messageData]);
    socket.emit("stop_typing", {
      channelId: activeChannel.id,
      username: user.username,
    });
    setCurrentMessage("");
    setSelectedFile(null);
    if (fileInputRef.current) fileInputRef.current.value = "";
    setTimeout(
      () => messagesEndRef.current?.scrollIntoView({ behavior: "smooth" }),
      0,
    );
  };

  const handleReaction = async (messageId, emoji) => {
    setActiveReactionMessageId(null);
    try {
      await api.post(`/messages/${messageId}/react`, {
        emoji,
        userId: user.id,
      });
      socket.emit("message_reaction", {
        messageId,
        channelId: activeChannel.id,
        userId: user.id,
        emoji,
      });
    } catch (err) {
      console.error("Failed to react", err);
    }
  };

  const handleTyping = (e) => {
    setCurrentMessage(e.target.value);
    socket.emit("typing", {
      channelId: activeChannel.id,
      username: user.username,
    });
    if (typingTimeoutRef.current) clearTimeout(typingTimeoutRef.current);
    typingTimeoutRef.current = setTimeout(() => {
      socket.emit("stop_typing", {
        channelId: activeChannel.id,
        username: user.username,
      });
    }, 2000);
  };

  const getMessageReadStatus = (msgId) => {
    if (!user) return false;
    return Object.entries(readStatus).some(
      ([uId, readId]) =>
        parseInt(uId) !== user.id && parseInt(readId) >= parseInt(msgId),
    );
  };

  const handleSearch = async (query) => {
    if (!query.trim()) {
      fetchMessages(true);
      return;
    }
    setIsSearching(true);
    try {
      const res = await api.get(
        `/messages/${activeChannel.id}/search?q=${query}`,
      );
      setMessages(res.data.messages || []);
      setHasMore(false);
    } catch (err) {
      toast.error("Search failed");
    } finally {
      setIsSearching(false);
    }
  };

  return (
    <div className="flex h-screen bg-gray-950 text-slate-100 overflow-hidden font-sans">
      <Toaster
        position="top-right"
        toastOptions={{
          style: {
            background: "#1e293b",
            color: "#fff",
            border: "1px solid #334155",
          },
        }}
      />

      {/* LIGHTBOX */}
      <AnimatePresence>
        {lightboxImage && (
          <motion.div
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            className="fixed inset-0 z-50 bg-black/90 backdrop-blur-md flex items-center justify-center p-4 cursor-zoom-out"
            onClick={() => setLightboxImage(null)}
          >
            <motion.img
              initial={{ scale: 0.9 }}
              animate={{ scale: 1 }}
              exit={{ scale: 0.9 }}
              src={lightboxImage}
              alt="Full view"
              className="max-w-full max-h-full rounded-lg shadow-2xl"
            />
            <button className="absolute top-6 right-6 text-white/70 hover:text-white p-2 bg-white/10 rounded-full">
              <X className="w-6 h-6" />
            </button>
          </motion.div>
        )}
      </AnimatePresence>

      {/* --- VIDEO CALL OVERLAY --- */}
      <AnimatePresence>
        {callStatus !== "idle" && (
          <motion.div
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            className="fixed inset-0 z-[100] bg-gray-950/80 backdrop-blur-lg flex items-center justify-center"
          >
            {/* CALLING / RECEIVING CARD */}
            {(callStatus === "calling" || callStatus === "receiving") && (
              <motion.div
                initial={{ scale: 0.9 }}
                animate={{ scale: 1 }}
                className="bg-gray-900 border border-gray-700 p-8 rounded-3xl shadow-2xl flex flex-col items-center"
              >
                <div className="w-24 h-24 bg-indigo-600 rounded-full flex items-center justify-center mb-6 shadow-lg shadow-indigo-500/30">
                  <Phone className="w-10 h-10 text-white animate-pulse" />
                </div>
                <h3 className="text-2xl font-bold mb-2">
                  {callStatus === "calling"
                    ? "Calling..."
                    : `${callData?.name} is calling...`}
                </h3>
                <p className="text-gray-400 mb-8">Video Call</p>

                <div className="flex gap-6">
                  {callStatus === "receiving" && (
                    <button
                      onClick={answerCall}
                      className="p-4 bg-emerald-500 hover:bg-emerald-600 rounded-full transition-all shadow-lg shadow-emerald-500/30"
                    >
                      <Video className="w-8 h-8 text-white" />
                    </button>
                  )}
                  <button
                    onClick={endCall}
                    className="p-4 bg-rose-500 hover:bg-rose-600 rounded-full transition-all shadow-lg shadow-rose-500/30"
                  >
                    <PhoneOff className="w-8 h-8 text-white" />
                  </button>
                </div>
              </motion.div>
            )}

            {/* CONNECTED VIDEO GRID */}
            {callStatus === "connected" && (
              <div className="w-full h-full p-4 flex flex-col gap-4">
                <div className="flex-1 relative bg-black rounded-3xl overflow-hidden shadow-2xl border border-gray-800">
                  <video
                    ref={remoteVideoRef}
                    autoPlay
                    playsInline
                    className="w-full h-full object-cover"
                  />
                  <div className="absolute bottom-6 left-6 bg-black/50 backdrop-blur-md px-4 py-2 rounded-xl text-white font-medium">
                    {callData?.name || "Remote User"}
                  </div>

                  {/* LOCAL VIDEO (PIP) */}
                  <div className="absolute top-6 right-6 w-48 h-36 bg-gray-800 rounded-2xl overflow-hidden border-2 border-gray-700 shadow-xl">
                    <video
                      ref={localVideoRef}
                      autoPlay
                      playsInline
                      muted
                      className="w-full h-full object-cover"
                    />
                  </div>
                </div>

                {/* CONTROLS */}
                <div className="h-24 bg-gray-900 border border-gray-800 rounded-3xl flex items-center justify-center gap-6 shadow-2xl">
                  <button
                    onClick={toggleMic}
                    className={`p-4 rounded-full transition-all ${isMicMuted ? "bg-red-500/20 text-red-500" : "bg-gray-800 hover:bg-gray-700 text-white"}`}
                  >
                    {isMicMuted ? <MicOff /> : <Mic />}
                  </button>
                  <button
                    onClick={endCall}
                    className="p-5 bg-rose-500 hover:bg-rose-600 rounded-full shadow-lg shadow-rose-500/30 text-white transform hover:scale-105 transition-all"
                  >
                    <PhoneOff className="w-8 h-8" />
                  </button>
                  <button
                    onClick={toggleVideo}
                    className={`p-4 rounded-full transition-all ${isVideoOff ? "bg-red-500/20 text-red-500" : "bg-gray-800 hover:bg-gray-700 text-white"}`}
                  >
                    {isVideoOff ? <CameraOff /> : <Camera />}
                  </button>
                </div>
              </div>
            )}
          </motion.div>
        )}
      </AnimatePresence>

      {/* MOBILE OVERLAY */}
      {isSidebarOpen && (
        <div
          className="fixed inset-0 bg-black/60 backdrop-blur-sm z-20 md:hidden"
          onClick={() => setIsSidebarOpen(false)}
        />
      )}

      {/* SIDEBAR */}
      <div
        className={`fixed inset-y-0 left-0 z-30 w-72 bg-gray-900 border-r border-gray-800 transform transition-transform duration-300 md:relative md:translate-x-0 flex flex-col ${isSidebarOpen ? "translate-x-0" : "-translate-x-full"}`}
      >
        <div className="p-6 border-b border-gray-800 flex items-center justify-between">
          <div className="flex items-center gap-3">
            <div className="bg-indigo-600 p-2 rounded-xl shadow-lg shadow-indigo-500/20">
              <MessageSquare className="w-6 h-6 text-white" />
            </div>
            <span className="font-bold text-xl tracking-tight">Nexus</span>
          </div>
          <div
            className={`w-3 h-3 rounded-full shadow-[0_0_12px] transition-all duration-500 ${isConnected ? "bg-emerald-500 shadow-emerald-500/50" : "bg-rose-500 shadow-rose-500/50"}`}
          />
        </div>

        <div className="flex-1 overflow-y-auto p-4 space-y-6">
          <div>
            <div className="px-2 mb-3 text-xs font-bold text-gray-500 uppercase tracking-wider">
              Channels
            </div>
            <div className="space-y-1">
              {channels.map((channel) => (
                <button
                  key={channel.id}
                  onClick={() => {
                    setActiveChannel(channel);
                    setIsSidebarOpen(false);
                  }}
                  className={`w-full flex items-center px-4 py-3 rounded-xl transition-all duration-200 group relative overflow-hidden ${activeChannel.id === channel.id ? "bg-indigo-600/10 text-indigo-400 border border-indigo-500/20" : "text-gray-400 hover:bg-gray-800 hover:text-gray-100"}`}
                >
                  <Hash
                    className={`w-4 h-4 mr-3 ${activeChannel.id === channel.id ? "text-indigo-400" : "text-gray-500 group-hover:text-gray-300"}`}
                  />
                  <span className="font-medium">{channel.name}</span>
                  {activeChannel.id === channel.id && (
                    <div className="absolute left-0 top-1/2 -translate-y-1/2 w-1 h-8 bg-indigo-500 rounded-r-full" />
                  )}
                </button>
              ))}
            </div>
          </div>

          <div>
            <div className="px-2 mb-3 text-xs font-bold text-gray-500 uppercase tracking-wider flex items-center justify-between">
              <span>Online ‚Äî {onlineUserIds.length}</span>
            </div>
            <div className="space-y-3 px-2">
              {/* --- 4. VIDEO CALL BUTTONS IN SIDEBAR --- */}
              {/* We render "Online Users" here. In a real app we'd fetch names. */}
              {/* Since we only have IDs, we just render "User {ID}" or similar if they aren't us */}
              {onlineUserIds.map((uid) => {
                const isMe = String(uid) === String(user?.id);
                if (isMe) return null; // Don't show myself

                return (
                  <div
                    key={uid}
                    className="flex items-center justify-between bg-gray-800/50 p-2 rounded-lg border border-gray-700/50 hover:bg-gray-800 transition-colors"
                  >
                    <div className="flex items-center gap-3">
                      <div className="relative">
                        <div className="w-8 h-8 rounded-full bg-gradient-to-br from-gray-600 to-gray-500 flex items-center justify-center text-xs font-bold shadow-inner">
                          {/* We don't have usernames for online list in this simple store, just IDs. */}
                          {/* Real app would fetch this. For now, use 'U' */}U
                        </div>
                        <div className="absolute -bottom-0.5 -right-0.5 w-2.5 h-2.5 bg-emerald-500 border-2 border-gray-800 rounded-full"></div>
                      </div>
                      <span className="text-xs font-medium text-gray-300">
                        User {uid}
                      </span>
                    </div>
                    <button
                      onClick={() => startCall(uid)}
                      className="p-1.5 text-gray-400 hover:text-indigo-400 hover:bg-indigo-500/10 rounded-lg transition-all"
                      title="Start Video Call"
                    >
                      <Video className="w-4 h-4" />
                    </button>
                  </div>
                );
              })}

              {/* Show Me at the bottom or separate */}
              {onlineUserIds.includes(user?.id) && (
                <div className="flex items-center gap-3 bg-indigo-900/20 p-2 rounded-lg border border-indigo-500/20 mt-4">
                  <div className="relative">
                    <div className="w-8 h-8 rounded-full bg-gradient-to-br from-indigo-500 to-purple-600 flex items-center justify-center text-xs font-bold shadow-inner">
                      {user?.username?.[0]?.toUpperCase()}
                    </div>
                    <div className="absolute -bottom-0.5 -right-0.5 w-2.5 h-2.5 bg-emerald-500 border-2 border-gray-800 rounded-full"></div>
                  </div>
                  <div className="flex flex-col">
                    <span className="text-xs font-medium text-white">You</span>
                    <span className="text-[10px] text-emerald-400">
                      Active now
                    </span>
                  </div>
                </div>
              )}
            </div>
          </div>
        </div>

        <div className="p-4 bg-gray-900 border-t border-gray-800">
          <button
            onClick={() => {
              logout();
              socket.disconnect();
              navigate("/login");
            }}
            className="w-full flex items-center justify-center gap-2 p-3 text-gray-400 hover:text-rose-400 hover:bg-rose-500/10 rounded-xl transition-all duration-200"
          >
            <LogOut className="w-5 h-5" />
            <span className="font-medium text-sm">Sign Out</span>
          </button>
        </div>
      </div>

      {/* MAIN AREA (Messages) */}
      <div className="flex-1 flex flex-col min-w-0 bg-gray-950 relative">
        <div className="h-20 glass-header flex items-center px-6 sticky top-0 z-20 justify-between">
          <div className="flex items-center w-full">
            <button
              onClick={() => setIsSidebarOpen(true)}
              className="mr-4 md:hidden text-gray-400 hover:text-white"
            >
              <Menu className="w-6 h-6" />
            </button>
            {isSearchOpen ? (
              <motion.div
                initial={{ opacity: 0, x: 20 }}
                animate={{ opacity: 1, x: 0 }}
                className="flex items-center w-full"
              >
                <button
                  onClick={() => {
                    setIsSearchOpen(false);
                    setSearchQuery("");
                    fetchMessages(true);
                  }}
                  className="mr-4 text-gray-400 hover:text-white p-2 rounded-full hover:bg-gray-800"
                >
                  <ArrowLeft className="w-5 h-5" />
                </button>
                <div className="relative flex-1 max-w-2xl">
                  <Search className="absolute left-4 top-3 w-5 h-5 text-gray-500" />
                  <input
                    autoFocus
                    type="text"
                    placeholder="Search conversation..."
                    className="w-full bg-gray-800/50 text-white pl-12 pr-4 py-2.5 rounded-full focus:outline-none focus:ring-2 focus:ring-indigo-500/50 border border-gray-700 placeholder-gray-500 transition-all"
                    value={searchQuery}
                    onChange={(e) => {
                      setSearchQuery(e.target.value);
                      if (searchTimeoutRef.current)
                        clearTimeout(searchTimeoutRef.current);
                      searchTimeoutRef.current = setTimeout(
                        () => handleSearch(e.target.value),
                        500,
                      );
                    }}
                  />
                </div>
              </motion.div>
            ) : (
              <>
                <div className="flex flex-col mr-auto">
                  <div className="flex items-center gap-2">
                    <Hash className="w-5 h-5 text-indigo-400" />
                    <span className="font-bold text-lg text-white tracking-tight">
                      {activeChannel.name}
                    </span>
                  </div>
                  <span className="text-xs text-gray-400 mt-0.5">
                    {onlineUserIds.length} members online
                  </span>
                </div>
                <button
                  onClick={() => setIsSearchOpen(true)}
                  className="p-3 text-gray-400 hover:bg-gray-800/80 rounded-xl transition-all duration-200 hover:text-white"
                >
                  <Search className="w-5 h-5" />
                </button>
              </>
            )}
          </div>
        </div>

        <div
          ref={messagesContainerRef}
          onScroll={handleScroll}
          className="flex-1 overflow-y-auto p-4 sm:p-8 space-y-2 scrollbar-thin"
          onClick={() => setActiveReactionMessageId(null)}
        >
          {isFetchingOld && (
            <div className="flex justify-center py-4">
              <Loader2 className="w-6 h-6 animate-spin text-indigo-500" />
            </div>
          )}

          {isSearching && messages.length === 0 && (
            <div className="flex flex-col items-center justify-center h-full text-gray-500">
              <Search className="w-12 h-12 mb-2 opacity-20" />
              <p>Searching...</p>
            </div>
          )}

          {isLoadingInitial ? (
            <div className="space-y-6">
              {[...Array(3)].map((_, i) => (
                <div key={i} className="flex gap-4 animate-pulse opacity-50">
                  <div className="w-10 h-10 bg-gray-800 rounded-full"></div>
                  <div className="space-y-2 flex-1">
                    <div className="h-4 bg-gray-800 rounded w-1/4"></div>
                    <div className="h-12 bg-gray-800 rounded-2xl w-1/2"></div>
                  </div>
                </div>
              ))}
            </div>
          ) : (
            <AnimatePresence initial={false}>
              {(messages || []).map((msg, idx) => {
                const isMe = msg.sender === user?.username;
                const reactionCounts = (msg.reactions || []).reduce(
                  (acc, curr) => {
                    acc[curr.emoji] = (acc[curr.emoji] || 0) + 1;
                    return acc;
                  },
                  {},
                );
                const isRead = isMe && getMessageReadStatus(msg.id);

                // --- SMART GROUPING LOGIC ---
                const prevMsg = messages[idx - 1];
                const isSequence = prevMsg && prevMsg.sender === msg.sender;

                return (
                  <motion.div
                    initial={{ opacity: 0, y: 10 }}
                    animate={{ opacity: 1, y: 0 }}
                    transition={{ duration: 0.2 }}
                    key={`${msg.id}-${idx}`}
                    className={`message-item flex w-full ${isMe ? "justify-end" : "justify-start"} group relative ${isSequence ? "mt-1" : "mt-6"}`}
                    data-msg-id={msg.id}
                  >
                    <div
                      className={`flex max-w-[85%] sm:max-w-[65%] ${isMe ? "flex-row-reverse" : "flex-row"} items-end gap-3`}
                    >
                      {!isMe && (
                        <div className="w-9 flex-shrink-0 flex flex-col items-center">
                          {!isSequence ? (
                            <div
                              className={`w-9 h-9 rounded-full flex items-center justify-center text-xs font-bold shadow-lg bg-gradient-to-br from-gray-700 to-gray-600`}
                            >
                              {msg.sender?.[0]?.toUpperCase()}
                            </div>
                          ) : (
                            <div className="w-9" />
                          )}
                        </div>
                      )}

                      <div
                        className={`flex flex-col ${isMe ? "items-end" : "items-start"}`}
                      >
                        {!isMe && !isSequence && (
                          <div className="flex items-center gap-2 mb-1 px-1">
                            <span className="text-xs font-semibold text-indigo-300">
                              {msg.sender}
                            </span>
                            <span className="text-[10px] text-gray-500">
                              {msg.time}
                            </span>
                          </div>
                        )}

                        <div className="relative group/bubble">
                          <div
                            className={`px-5 py-3 shadow-sm text-[15px] leading-relaxed break-words relative backdrop-blur-sm border 
                            ${
                              isMe
                                ? `bg-indigo-600/90 text-white border-indigo-500/50 ${isSequence ? "rounded-3xl rounded-tr-md" : "rounded-3xl rounded-br-none"}`
                                : `glass text-gray-100 border-gray-700/50 ${isSequence ? "rounded-3xl rounded-tl-md" : "rounded-3xl rounded-bl-none"}`
                            }`}
                          >
                            {msg.attachmentUrl && (
                              <div className="mb-3 rounded-xl overflow-hidden border border-white/10 shadow-sm relative group/image">
                                <img
                                  src={msg.attachmentUrl}
                                  alt="attachment"
                                  className="max-w-full h-auto max-h-72 object-cover hover:scale-105 transition-transform duration-300 cursor-pointer"
                                  onClick={() =>
                                    setLightboxImage(msg.attachmentUrl)
                                  }
                                />
                                <div className="absolute inset-0 bg-black/20 opacity-0 group-hover/image:opacity-100 transition-opacity flex items-center justify-center pointer-events-none">
                                  <Maximize2 className="w-6 h-6 text-white drop-shadow-md" />
                                </div>
                              </div>
                            )}
                            {msg.content}
                          </div>

                          <button
                            onClick={(e) => {
                              e.stopPropagation();
                              setActiveReactionMessageId(
                                activeReactionMessageId === msg.id
                                  ? null
                                  : msg.id,
                              );
                            }}
                            className={`absolute -top-3 ${isMe ? "-left-8" : "-right-8"} p-1.5 rounded-full bg-gray-800 border border-gray-700 text-gray-400 hover:text-amber-400 hover:bg-gray-700 transition-all opacity-0 group-hover/bubble:opacity-100 scale-90 hover:scale-100 shadow-lg`}
                          >
                            <Smile className="w-4 h-4" />
                          </button>

                          <div
                            className={`absolute -bottom-5 ${isMe ? "right-0" : "left-0"} flex items-center gap-2 z-10`}
                          >
                            {isMe &&
                              (idx === messages.length - 1 || !isSequence) && (
                                <span className="opacity-0 group-hover/bubble:opacity-100 transition-opacity duration-200">
                                  {isRead ? (
                                    <CheckCheck className="w-3.5 h-3.5 text-indigo-400" />
                                  ) : (
                                    <Check className="w-3.5 h-3.5 text-gray-600" />
                                  )}
                                </span>
                              )}
                            {Object.entries(reactionCounts).length > 0 && (
                              <div className="flex gap-1 transform -translate-y-2">
                                {Object.entries(reactionCounts).map(
                                  ([emoji, count]) => (
                                    <div
                                      key={emoji}
                                      className="bg-gray-800/90 border border-gray-700/50 rounded-full px-1.5 py-0.5 text-[10px] flex items-center gap-1 shadow-md text-gray-300"
                                    >
                                      <span>{emoji}</span>
                                      <span>{count > 1 ? count : ""}</span>
                                    </div>
                                  ),
                                )}
                              </div>
                            )}
                          </div>

                          <AnimatePresence>
                            {activeReactionMessageId === msg.id && (
                              <motion.div
                                initial={{ scale: 0.8, opacity: 0 }}
                                animate={{ scale: 1, opacity: 1 }}
                                exit={{ scale: 0.8, opacity: 0 }}
                                className={`absolute z-20 -top-14 ${isMe ? "right-0" : "left-0"} bg-gray-800/90 backdrop-blur-md border border-gray-700 rounded-full shadow-2xl flex items-center p-1.5 gap-1`}
                              >
                                {["üëç", "‚ù§Ô∏è", "üòÇ", "üòÆ", "üò¢", "üò°"].map(
                                  (emoji) => (
                                    <button
                                      key={emoji}
                                      onClick={(e) => {
                                        e.stopPropagation();
                                        handleReaction(msg.id, emoji);
                                      }}
                                      className="w-9 h-9 flex items-center justify-center hover:bg-white/10 rounded-full text-xl transition-colors"
                                    >
                                      {emoji}
                                    </button>
                                  ),
                                )}
                              </motion.div>
                            )}
                          </AnimatePresence>
                        </div>
                      </div>
                    </div>
                  </motion.div>
                );
              })}
            </AnimatePresence>
          )}

          {typingUsers.length > 0 && (
            <motion.div
              initial={{ opacity: 0, y: 10 }}
              animate={{ opacity: 1, y: 0 }}
              className="flex items-center gap-3 text-gray-500 text-xs ml-12 mt-4"
            >
              <div className="flex gap-1 bg-gray-800/50 p-2 rounded-xl">
                <span className="w-1.5 h-1.5 bg-indigo-400 rounded-full animate-bounce"></span>
                <span className="w-1.5 h-1.5 bg-indigo-400 rounded-full animate-bounce delay-75"></span>
                <span className="w-1.5 h-1.5 bg-indigo-400 rounded-full animate-bounce delay-150"></span>
              </div>
              <span className="font-medium text-indigo-400">
                {typingUsers.join(", ")} is typing...
              </span>
            </motion.div>
          )}
          <div ref={messagesEndRef} />
        </div>

        <div className="p-4 bg-gray-950/80 backdrop-blur-md border-t border-gray-800/50">
          <div className="max-w-4xl mx-auto">
            {selectedFile && (
              <motion.div
                initial={{ opacity: 0, y: 10 }}
                animate={{ opacity: 1, y: 0 }}
                className="mb-4 inline-flex items-center gap-3 bg-gray-900 p-2 pr-4 rounded-xl border border-gray-800 shadow-lg"
              >
                <div className="relative group">
                  <img
                    src={URL.createObjectURL(selectedFile)}
                    alt="preview"
                    className="w-12 h-12 object-cover rounded-lg"
                  />
                  <button
                    onClick={() => {
                      setSelectedFile(null);
                      if (fileInputRef.current) fileInputRef.current.value = "";
                    }}
                    className="absolute -top-2 -right-2 bg-rose-500 text-white rounded-full p-0.5 shadow-md hover:bg-rose-600 transition-colors"
                  >
                    <X className="w-3 h-3" />
                  </button>
                </div>
                <div className="text-sm">
                  <div className="font-medium text-gray-200">
                    Image selected
                  </div>
                  <div className="text-xs text-gray-500 truncate max-w-[150px]">
                    {selectedFile.name}
                  </div>
                </div>
              </motion.div>
            )}

            <form
              onSubmit={handleSendMessage}
              className={`flex gap-3 items-end transition-opacity duration-300 ${isSearchOpen ? "opacity-30 pointer-events-none" : "opacity-100"}`}
            >
              <input
                type="file"
                ref={fileInputRef}
                onChange={(e) => {
                  const file = e.target.files[0];
                  if (file) setSelectedFile(file);
                }}
                className="hidden"
                accept="image/*"
              />
              <button
                type="button"
                onClick={() => fileInputRef.current?.click()}
                className="p-3.5 bg-gray-800 hover:bg-gray-700 text-gray-400 hover:text-indigo-400 rounded-2xl transition-all border border-gray-700/50 shadow-sm hover:shadow-indigo-500/10"
                title="Attach Image"
              >
                <Paperclip className="w-5 h-5" />
              </button>

              <div className="relative flex-1">
                <input
                  type="text"
                  value={currentMessage}
                  onChange={handleTyping}
                  placeholder={`Message #${activeChannel.name}`}
                  className="w-full bg-gray-800/50 hover:bg-gray-800 text-white pl-5 pr-4 py-3.5 rounded-2xl focus:outline-none focus:ring-2 focus:ring-indigo-500/50 focus:bg-gray-800 transition-all shadow-inner border border-gray-700/50 placeholder-gray-500"
                />
              </div>

              <button
                type="submit"
                disabled={
                  (!currentMessage.trim() && !selectedFile) || isUploading
                }
                className={`p-3.5 rounded-2xl transition-all duration-200 flex items-center justify-center shadow-lg ${(currentMessage.trim() || selectedFile) && !isUploading ? "bg-indigo-600 hover:bg-indigo-500 text-white shadow-indigo-600/20 hover:scale-105 active:scale-95" : "bg-gray-800 text-gray-500 cursor-not-allowed border border-gray-700"}`}
              >
                {isUploading ? (
                  <Loader2 className="w-5 h-5 animate-spin" />
                ) : (
                  <Send className="w-5 h-5" />
                )}
              </button>
            </form>
          </div>
        </div>
      </div>
    </div>
  );
};

export default Chat;
</file>

<file path="frontend/src/pages/Login.jsx">
import { useState } from "react";
import { useAuthStore } from "../store/useAuthStore";
import { useNavigate, Link } from "react-router-dom";
import { MessageSquare, Loader2 } from "lucide-react";

const Login = () => {
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const { login, isLoggingIn } = useAuthStore();
  const navigate = useNavigate();

  const handleSubmit = async (e) => {
    e.preventDefault();
    const success = await login(email, password);
    if (success) {
      navigate("/chat");
    } else {
      alert("Invalid credentials. Try again.");
    }
  };

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-900 p-4">
      <div className="bg-gray-800 p-8 rounded-2xl shadow-xl w-full max-w-md border border-gray-700">
        <div className="flex flex-col items-center mb-8">
          <div className="p-3 bg-blue-600 rounded-xl shadow-lg mb-4">
            <MessageSquare className="w-8 h-8 text-white" />
          </div>
          <h2 className="text-3xl font-bold text-white">Welcome Back</h2>
          <p className="text-gray-400 mt-2">Sign in to your Nexus account</p>
        </div>

        <form onSubmit={handleSubmit} className="space-y-6">
          <div>
            <label className="block text-sm font-medium text-gray-300 mb-2">
              Email
            </label>
            <input
              type="email"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              className="w-full p-3 bg-gray-700/50 border border-gray-600 rounded-lg text-white focus:ring-2 focus:ring-blue-500 focus:border-transparent outline-none transition-all placeholder-gray-500"
              placeholder="you@example.com"
              required
            />
          </div>

          <div>
            <label className="block text-sm font-medium text-gray-300 mb-2">
              Password
            </label>
            <input
              type="password"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              className="w-full p-3 bg-gray-700/50 border border-gray-600 rounded-lg text-white focus:ring-2 focus:ring-blue-500 focus:border-transparent outline-none transition-all placeholder-gray-500"
              placeholder="‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢"
              required
            />
          </div>

          <button
            type="submit"
            disabled={isLoggingIn}
            className="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3.5 rounded-lg transition-all shadow-lg shadow-blue-600/20 flex items-center justify-center disabled:opacity-50 disabled:cursor-not-allowed"
          >
            {isLoggingIn ? (
              <>
                <Loader2 className="w-5 h-5 animate-spin mr-2" />
                Signing in...
              </>
            ) : (
              "Sign In"
            )}
          </button>
        </form>

        <div className="mt-6 text-center">
          <p className="text-gray-400 text-sm">
            Don't have an account?{" "}
            <Link
              to="/signup"
              className="text-blue-400 hover:text-blue-300 font-medium hover:underline"
            >
              Create account
            </Link>
          </p>
        </div>
      </div>
    </div>
  );
};

export default Login;
</file>

<file path="frontend/src/pages/Signup.jsx">
import { useState } from "react";
import { useAuthStore } from "../store/useAuthStore";
import { useNavigate, Link } from "react-router-dom";
import { MessageSquare, User, Mail, Lock, Loader2 } from "lucide-react";

const Signup = () => {
  const [formData, setFormData] = useState({
    username: "",
    email: "",
    password: "",
  });

  const { signup, isSigningUp } = useAuthStore();
  const navigate = useNavigate();

  const handleSubmit = async (e) => {
    e.preventDefault();
    // Capture the result object
    const result = await signup(formData);

    if (result.success) {
      navigate("/chat");
    } else {
      // ALERT THE REAL REASON (e.g., "Too many attempts", "Database error")
      alert(result.message);
    }
  };

  return (
    <div className="min-h-screen flex items-center justify-center bg-gray-900 p-4">
      <div className="bg-gray-800 p-8 rounded-2xl shadow-xl w-full max-w-md border border-gray-700">
        <div className="flex flex-col items-center mb-8">
          <div className="p-3 bg-blue-600 rounded-xl shadow-lg mb-4">
            <MessageSquare className="w-8 h-8 text-white" />
          </div>
          <h2 className="text-3xl font-bold text-white">Create Account</h2>
          <p className="text-gray-400 mt-2">Get started with Nexus Chat</p>
        </div>

        <form onSubmit={handleSubmit} className="space-y-5">
          <div className="relative">
            <User className="absolute left-3 top-3.5 w-5 h-5 text-gray-500" />
            <input
              type="text"
              placeholder="Username"
              className="w-full pl-10 p-3 bg-gray-700/50 border border-gray-600 rounded-lg text-white focus:ring-2 focus:ring-blue-500 outline-none placeholder-gray-500"
              value={formData.username}
              onChange={(e) =>
                setFormData({ ...formData, username: e.target.value })
              }
              required
            />
          </div>

          <div className="relative">
            <Mail className="absolute left-3 top-3.5 w-5 h-5 text-gray-500" />
            <input
              type="email"
              placeholder="Email"
              className="w-full pl-10 p-3 bg-gray-700/50 border border-gray-600 rounded-lg text-white focus:ring-2 focus:ring-blue-500 outline-none placeholder-gray-500"
              value={formData.email}
              onChange={(e) =>
                setFormData({ ...formData, email: e.target.value })
              }
              required
            />
          </div>

          <div className="relative">
            <Lock className="absolute left-3 top-3.5 w-5 h-5 text-gray-500" />
            <input
              type="password"
              placeholder="Password"
              className="w-full pl-10 p-3 bg-gray-700/50 border border-gray-600 rounded-lg text-white focus:ring-2 focus:ring-blue-500 outline-none placeholder-gray-500"
              value={formData.password}
              onChange={(e) =>
                setFormData({ ...formData, password: e.target.value })
              }
              required
            />
          </div>

          <button
            type="submit"
            disabled={isSigningUp}
            className="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3.5 rounded-lg transition-all shadow-lg flex items-center justify-center disabled:opacity-50"
          >
            {isSigningUp ? (
              <>
                <Loader2 className="w-5 h-5 animate-spin mr-2" />
                Creating Account...
              </>
            ) : (
              "Sign Up"
            )}
          </button>
        </form>

        <div className="mt-6 text-center">
          <p className="text-gray-400 text-sm">
            Already have an account?{" "}
            <Link
              to="/login"
              className="text-blue-400 hover:text-blue-300 font-medium hover:underline"
            >
              Sign in
            </Link>
          </p>
        </div>
      </div>
    </div>
  );
};

export default Signup;
</file>

<file path="frontend/src/store/useAuthStore.js">
import { create } from "zustand";
import api from "../api/axios";

export const useAuthStore = create((set) => ({
  user: (() => {
    try {
      const storedUser = localStorage.getItem("user");
      return storedUser ? JSON.parse(storedUser) : null;
    } catch (err) {
      console.error("Failed to parse user from local storage:", err);
      return null;
    }
  })(),

  token: localStorage.getItem("token") || null,
  isAuthenticated: !!localStorage.getItem("token"),
  isSigningUp: false,
  isLoggingIn: false,
  isCheckingAuth: true,

  checkAuth: async () => {
    try {
      const token = localStorage.getItem("token");
      let user = null;
      try {
        const storedUser = localStorage.getItem("user");
        if (storedUser) user = JSON.parse(storedUser);
      } catch (e) {
        console.error("Auth check parse error", e);
      }

      if (token && user) {
        set({ isAuthenticated: true, token, user, isCheckingAuth: false });
      } else {
        set({
          isAuthenticated: false,
          token: null,
          user: null,
          isCheckingAuth: false,
        });
        localStorage.removeItem("token");
        localStorage.removeItem("user");
      }
    } catch (error) {
      console.log("Auth check error", error);
      set({ isAuthenticated: false, token: null, isCheckingAuth: false });
    }
  },

  signup: async (formData) => {
    set({ isSigningUp: true });
    try {
      const res = await api.post("/auth/register", formData);

      localStorage.setItem("token", res.data.token);
      localStorage.setItem("user", JSON.stringify(res.data.user));

      set({
        user: res.data.user,
        token: res.data.token,
        isAuthenticated: true,
      });
      return { success: true };
    } catch (error) {
      console.error("Signup error:", error);
      // RETURN THE REAL ERROR MESSAGE
      const message = error.response?.data?.message || "Signup failed";
      return { success: false, message };
    } finally {
      set({ isSigningUp: false });
    }
  },

  login: async (email, password) => {
    set({ isLoggingIn: true });
    try {
      const res = await api.post("/auth/login", { email, password });

      localStorage.setItem("token", res.data.token);
      localStorage.setItem("user", JSON.stringify(res.data.user));

      set({
        user: res.data.user,
        token: res.data.token,
        isAuthenticated: true,
      });
      return { success: true };
    } catch (error) {
      console.error("Login error:", error);
      const message = error.response?.data?.message || "Login failed";
      return { success: false, message };
    } finally {
      set({ isLoggingIn: false });
    }
  },

  logout: () => {
    localStorage.removeItem("token");
    localStorage.removeItem("user");
    set({ user: null, token: null, isAuthenticated: false });
  },
}));
</file>

<file path="frontend/src/App.css">

</file>

<file path="frontend/src/App.jsx">
import { useEffect } from "react";
import { BrowserRouter, Routes, Route, Navigate } from "react-router-dom";
import { useAuthStore } from "./store/useAuthStore";
import Login from "./pages/Login";
import Chat from "./pages/Chat";
import Signup from "./pages/Signup"; // Ensure this file exists, or remove this line

// Protected Route Component: Redirects to /login if not authenticated
const ProtectedRoute = ({ children }) => {
  const { isAuthenticated } = useAuthStore();

  if (!isAuthenticated) {
    return <Navigate to="/login" />;
  }
  return children;
};

function App() {
  const { checkAuth, isCheckingAuth } = useAuthStore();

  // FIX: Actually call the function inside useEffect
  useEffect(() => {
    checkAuth();
  }, [checkAuth]);

  // Optional: Show a loading spinner while checking auth
  if (isCheckingAuth && !useAuthStore.getState().isAuthenticated) {
    return (
      <div className="flex items-center justify-center h-screen bg-gray-900 text-white">
        <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-blue-500"></div>
      </div>
    );
  }

  return (
    <BrowserRouter>
      <Routes>
        <Route path="/login" element={<Login />} />
        <Route path="/signup" element={<Signup />} />

        {/* Protected Chat Route */}
        <Route
          path="/chat"
          element={
            <ProtectedRoute>
              <Chat />
            </ProtectedRoute>
          }
        />

        {/* Redirect unknown routes to chat (which will redirect to login if needed) */}
        <Route path="*" element={<Navigate to="/chat" />} />
      </Routes>
    </BrowserRouter>
  );
}

export default App;
</file>

<file path="frontend/src/index.css">
@import "tailwindcss";

@theme {
  --color-gray-950: #020617;
  --color-gray-900: #0f172a;
  --color-gray-800: #1e293b;
  --color-gray-700: #334155;
}

body {
  background-color: var(--color-gray-950);
  color: #f8fafc;
  font-family:
    "Inter",
    system-ui,
    -apple-system,
    sans-serif;
  -webkit-font-smoothing: antialiased;
}

/* Custom Scrollbar for that "Premium" feel */
::-webkit-scrollbar {
  width: 6px;
}
::-webkit-scrollbar-track {
  background: transparent;
}
::-webkit-scrollbar-thumb {
  background: #334155;
  border-radius: 10px;
}
::-webkit-scrollbar-thumb:hover {
  background: #475569;
}

/* Glassmorphism Utilities */
.glass {
  background: rgba(30, 41, 59, 0.7);
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
  border: 1px solid rgba(255, 255, 255, 0.05);
}

.glass-header {
  background: rgba(15, 23, 42, 0.85);
  backdrop-filter: blur(12px);
  border-bottom: 1px solid rgba(255, 255, 255, 0.05);
}
</file>

<file path="frontend/src/main.jsx">
import { StrictMode } from "react";
import { createRoot } from "react-dom/client";
import App from "./App.jsx";
import "./index.css";

createRoot(document.getElementById("root")).render(
  <StrictMode>
    <App />
  </StrictMode>,
);
</file>

<file path="frontend/.gitignore">
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?
</file>

<file path="frontend/eslint.config.js">
import js from '@eslint/js'
import globals from 'globals'
import reactHooks from 'eslint-plugin-react-hooks'
import reactRefresh from 'eslint-plugin-react-refresh'
import { defineConfig, globalIgnores } from 'eslint/config'

export default defineConfig([
  globalIgnores(['dist']),
  {
    files: ['**/*.{js,jsx}'],
    extends: [
      js.configs.recommended,
      reactHooks.configs.flat.recommended,
      reactRefresh.configs.vite,
    ],
    languageOptions: {
      ecmaVersion: 2020,
      globals: globals.browser,
      parserOptions: {
        ecmaVersion: 'latest',
        ecmaFeatures: { jsx: true },
        sourceType: 'module',
      },
    },
    rules: {
      'no-unused-vars': ['error', { varsIgnorePattern: '^[A-Z_]' }],
    },
  },
])
</file>

<file path="frontend/index.html">
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>frontend</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>
</file>

<file path="frontend/package.json">
{
  "name": "frontend",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "lint": "eslint .",
    "preview": "vite preview"
  },
  "dependencies": {
    "axios": "^1.13.5",
    "clsx": "^2.1.1",
    "framer-motion": "^12.34.0",
    "lucide-react": "^0.564.0",
    "react": "^19.2.0",
    "react-dom": "^19.2.0",
    "react-hot-toast": "^2.6.0",
    "react-router-dom": "^7.13.0",
    "socket.io-client": "^4.8.3",
    "tailwind-merge": "^3.4.1",
    "zustand": "^5.0.11"
  },
  "devDependencies": {
    "@eslint/js": "^9.39.1",
    "@tailwindcss/postcss": "^4.1.18",
    "@types/react": "^19.2.7",
    "@types/react-dom": "^19.2.3",
    "@vitejs/plugin-react": "^5.1.1",
    "autoprefixer": "^10.4.24",
    "eslint": "^9.39.1",
    "eslint-plugin-react-hooks": "^7.0.1",
    "eslint-plugin-react-refresh": "^0.4.24",
    "globals": "^16.5.0",
    "postcss": "^8.5.6",
    "tailwindcss": "^4.1.18",
    "vite": "^7.3.1"
  }
}
</file>

<file path="frontend/postcss.config.js">
export default {
  plugins: {
    "@tailwindcss/postcss": {}, // <--- This is the new v4 plugin
    autoprefixer: {},
  },
};
</file>

<file path="frontend/README.md">
# React + Vite

This template provides a minimal setup to get React working in Vite with HMR and some ESLint rules.

Currently, two official plugins are available:

- [@vitejs/plugin-react](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react) uses [Babel](https://babeljs.io/) (or [oxc](https://oxc.rs) when used in [rolldown-vite](https://vite.dev/guide/rolldown)) for Fast Refresh
- [@vitejs/plugin-react-swc](https://github.com/vitejs/vite-plugin-react/blob/main/packages/plugin-react-swc) uses [SWC](https://swc.rs/) for Fast Refresh

## React Compiler

The React Compiler is not enabled on this template because of its impact on dev & build performances. To add it, see [this documentation](https://react.dev/learn/react-compiler/installation).

## Expanding the ESLint configuration

If you are developing a production application, we recommend using TypeScript with type-aware lint rules enabled. Check out the [TS template](https://github.com/vitejs/vite/tree/main/packages/create-vite/template-react-ts) for information on how to integrate TypeScript and [`typescript-eslint`](https://typescript-eslint.io) in your project.
</file>

<file path="frontend/taiwind.config.js">
/** @type {import('tailwindcss').Config} */
export default {
  content: ["./index.html", "./src/**/*.{js,ts,jsx,tsx}"],
  theme: {
    extend: {},
  },
  plugins: [],
};
</file>

<file path="frontend/vite.config.js">
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vite.dev/config/
export default defineConfig({
  plugins: [react()],
})
</file>

<file path="README.md">
# chat-app-v2
</file>

</files>
